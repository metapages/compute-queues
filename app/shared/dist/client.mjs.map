{
  "version": 3,
  "sources": ["../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/fetch-retry@5.0.6/node_modules/fetch-retry/dist/fetch-retry.umd.js", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/safe-stable-stringify@2.4.3/node_modules/safe-stable-stringify/index.js", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/index.js", "../src/shared/types.ts", "../src/shared/util.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/interface.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/constant.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/internal.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/proto.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/draft.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/copy.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/mark.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/deepFreeze.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/forEach.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/finalize.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/patch.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/unsafe.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/map.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/set.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/draft.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/draftify.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/current.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/makeCreator.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/create.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/apply.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/original.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/rawReturn.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/marker.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/mutative@1.0.11/node_modules/mutative/src/utils/cast.ts", "../../../../root/.cache/deno/deno_esbuild/registry.npmjs.org/safe-stable-stringify@2.4.3/node_modules/safe-stable-stringify/esm/wrapper.js", "../src/shared/base64.ts", "../src/shared/dataref.ts"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.fetchRetry = factory());\n})(this, (function () { 'use strict';\n\n  var fetchRetry = function (fetch, defaults) {\n    defaults = defaults || {};\n    if (typeof fetch !== 'function') {\n      throw new ArgumentError('fetch must be a function');\n    }\n\n    if (typeof defaults !== 'object') {\n      throw new ArgumentError('defaults must be an object');\n    }\n\n    if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {\n      throw new ArgumentError('retries must be a positive integer');\n    }\n\n    if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {\n      throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n    }\n\n    if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {\n      throw new ArgumentError('retryOn property expects an array or function');\n    }\n\n    var baseDefaults = {\n      retries: 3,\n      retryDelay: 1000,\n      retryOn: [],\n    };\n\n    defaults = Object.assign(baseDefaults, defaults);\n\n    return function fetchRetry(input, init) {\n      var retries = defaults.retries;\n      var retryDelay = defaults.retryDelay;\n      var retryOn = defaults.retryOn;\n\n      if (init && init.retries !== undefined) {\n        if (isPositiveInteger(init.retries)) {\n          retries = init.retries;\n        } else {\n          throw new ArgumentError('retries must be a positive integer');\n        }\n      }\n\n      if (init && init.retryDelay !== undefined) {\n        if (isPositiveInteger(init.retryDelay) || (typeof init.retryDelay === 'function')) {\n          retryDelay = init.retryDelay;\n        } else {\n          throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n        }\n      }\n\n      if (init && init.retryOn) {\n        if (Array.isArray(init.retryOn) || (typeof init.retryOn === 'function')) {\n          retryOn = init.retryOn;\n        } else {\n          throw new ArgumentError('retryOn property expects an array or function');\n        }\n      }\n\n      // eslint-disable-next-line no-undef\n      return new Promise(function (resolve, reject) {\n        var wrappedFetch = function (attempt) {\n          // As of node 18, this is no longer needed since node comes with native support for fetch:\n          /* istanbul ignore next */\n          var _input =\n            typeof Request !== 'undefined' && input instanceof Request\n              ? input.clone()\n              : input;\n          fetch(_input, init)\n            .then(function (response) {\n              if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {\n                resolve(response);\n              } else if (typeof retryOn === 'function') {\n                try {\n                  // eslint-disable-next-line no-undef\n                  return Promise.resolve(retryOn(attempt, null, response))\n                    .then(function (retryOnResponse) {\n                      if(retryOnResponse) {\n                        retry(attempt, null, response);\n                      } else {\n                        resolve(response);\n                      }\n                    }).catch(reject);\n                } catch (error) {\n                  reject(error);\n                }\n              } else {\n                if (attempt < retries) {\n                  retry(attempt, null, response);\n                } else {\n                  resolve(response);\n                }\n              }\n            })\n            .catch(function (error) {\n              if (typeof retryOn === 'function') {\n                try {\n                  // eslint-disable-next-line no-undef\n                  Promise.resolve(retryOn(attempt, error, null))\n                    .then(function (retryOnResponse) {\n                      if(retryOnResponse) {\n                        retry(attempt, error, null);\n                      } else {\n                        reject(error);\n                      }\n                    })\n                    .catch(function(error) {\n                      reject(error);\n                    });\n                } catch(error) {\n                  reject(error);\n                }\n              } else if (attempt < retries) {\n                retry(attempt, error, null);\n              } else {\n                reject(error);\n              }\n            });\n        };\n\n        function retry(attempt, error, response) {\n          var delay = (typeof retryDelay === 'function') ?\n            retryDelay(attempt, error, response) : retryDelay;\n          setTimeout(function () {\n            wrappedFetch(++attempt);\n          }, delay);\n        }\n\n        wrappedFetch(0);\n      });\n    };\n  };\n\n  function isPositiveInteger(value) {\n    return Number.isInteger(value) && value >= 0;\n  }\n\n  function ArgumentError(message) {\n    this.name = 'ArgumentError';\n    this.message = message;\n  }\n\n  return fetchRetry;\n\n}));\n", "'use strict'\n\nconst { hasOwnProperty } = Object.prototype\n\nconst stringify = configure()\n\n// @ts-expect-error\nstringify.configure = configure\n// @ts-expect-error\nstringify.stringify = stringify\n\n// @ts-expect-error\nstringify.default = stringify\n\n// @ts-expect-error used for named export\nexports.stringify = stringify\n// @ts-expect-error used for named export\nexports.configure = configure\n\nmodule.exports = stringify\n\n// eslint-disable-next-line no-control-regex\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/\n\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape (str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 8.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return `\"${str}\"`\n  }\n  return JSON.stringify(str)\n}\n\nfunction insertSort (array) {\n  // Insertion sort is very efficient for small input sizes but it has a bad\n  // worst case complexity. Thus, use native array sort for bigger values.\n  if (array.length > 2e2) {\n    return array.sort()\n  }\n  for (let i = 1; i < array.length; i++) {\n    const currentValue = array[i]\n    let position = i\n    while (position !== 0 && array[position - 1] > currentValue) {\n      array[position] = array[position - 1]\n      position--\n    }\n    array[position] = currentValue\n  }\n  return array\n}\n\nconst typedArrayPrototypeGetSymbolToStringTag =\n  Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(\n      Object.getPrototypeOf(\n        new Int8Array()\n      )\n    ),\n    Symbol.toStringTag\n  ).get\n\nfunction isTypedArrayWithEntries (value) {\n  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0\n}\n\nfunction stringifyTypedArray (array, separator, maximumBreadth) {\n  if (array.length < maximumBreadth) {\n    maximumBreadth = array.length\n  }\n  const whitespace = separator === ',' ? '' : ' '\n  let res = `\"0\":${whitespace}${array[0]}`\n  for (let i = 1; i < maximumBreadth; i++) {\n    res += `${separator}\"${i}\":${whitespace}${array[i]}`\n  }\n  return res\n}\n\nfunction getCircularValueOption (options) {\n  if (hasOwnProperty.call(options, 'circularValue')) {\n    const circularValue = options.circularValue\n    if (typeof circularValue === 'string') {\n      return `\"${circularValue}\"`\n    }\n    if (circularValue == null) {\n      return circularValue\n    }\n    if (circularValue === Error || circularValue === TypeError) {\n      return {\n        toString () {\n          throw new TypeError('Converting circular structure to JSON')\n        }\n      }\n    }\n    throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined')\n  }\n  return '\"[Circular]\"'\n}\n\nfunction getBooleanOption (options, key) {\n  let value\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key]\n    if (typeof value !== 'boolean') {\n      throw new TypeError(`The \"${key}\" argument must be of type boolean`)\n    }\n  }\n  return value === undefined ? true : value\n}\n\nfunction getPositiveIntegerOption (options, key) {\n  let value\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key]\n    if (typeof value !== 'number') {\n      throw new TypeError(`The \"${key}\" argument must be of type number`)\n    }\n    if (!Number.isInteger(value)) {\n      throw new TypeError(`The \"${key}\" argument must be an integer`)\n    }\n    if (value < 1) {\n      throw new RangeError(`The \"${key}\" argument must be >= 1`)\n    }\n  }\n  return value === undefined ? Infinity : value\n}\n\nfunction getItemCount (number) {\n  if (number === 1) {\n    return '1 item'\n  }\n  return `${number} items`\n}\n\nfunction getUniqueReplacerSet (replacerArray) {\n  const replacerSet = new Set()\n  for (const value of replacerArray) {\n    if (typeof value === 'string' || typeof value === 'number') {\n      replacerSet.add(String(value))\n    }\n  }\n  return replacerSet\n}\n\nfunction getStrictOption (options) {\n  if (hasOwnProperty.call(options, 'strict')) {\n    const value = options.strict\n    if (typeof value !== 'boolean') {\n      throw new TypeError('The \"strict\" argument must be of type boolean')\n    }\n    if (value) {\n      return (value) => {\n        let message = `Object can not safely be stringified. Received type ${typeof value}`\n        if (typeof value !== 'function') message += ` (${value.toString()})`\n        throw new Error(message)\n      }\n    }\n  }\n}\n\nfunction configure (options) {\n  options = { ...options }\n  const fail = getStrictOption(options)\n  if (fail) {\n    if (options.bigint === undefined) {\n      options.bigint = false\n    }\n    if (!('circularValue' in options)) {\n      options.circularValue = Error\n    }\n  }\n  const circularValue = getCircularValueOption(options)\n  const bigint = getBooleanOption(options, 'bigint')\n  const deterministic = getBooleanOption(options, 'deterministic')\n  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')\n  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')\n\n  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {\n    let value = parent[key]\n\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n    value = replacer.call(parent, key, value)\n\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n        let join = ','\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let whitespace = ''\n        let separator = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (deterministic && !isTypedArrayWithEntries(value)) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":${whitespace}\"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        const originalIndentation = indentation\n        let res = ''\n        let join = ','\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n        stack.push(value)\n        let whitespace = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        let separator = ''\n        for (const key of replacer) {\n          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifyIndent (key, value, stack, spacer, indentation) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again.\n          if (typeof value !== 'object') {\n            return stringifyIndent(key, value, stack, spacer, indentation)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          indentation += spacer\n          let res = `\\n${indentation}`\n          const join = `,\\n${indentation}`\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          res += `\\n${originalIndentation}`\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        indentation += spacer\n        const join = `,\\n${indentation}`\n        let res = ''\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, join, maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = join\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}: ${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\": \"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (separator !== '') {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifySimple (key, value, stack) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again\n          if (typeof value !== 'object') {\n            return stringifySimple(key, value, stack)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifySimple(String(i), value[i], stack)\n            res += tmp !== undefined ? tmp : 'null'\n            res += ','\n          }\n          const tmp = stringifySimple(String(i), value[i], stack)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `,\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, ',', maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = ','\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifySimple(key, value[key], stack)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${tmp}`\n            separator = ','\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":\"${getItemCount(removedKeys)} not stringified\"`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringify (value, replacer, space) {\n    if (arguments.length > 1) {\n      let spacer = ''\n      if (typeof space === 'number') {\n        spacer = ' '.repeat(Math.min(space, 10))\n      } else if (typeof space === 'string') {\n        spacer = space.slice(0, 10)\n      }\n      if (replacer != null) {\n        if (typeof replacer === 'function') {\n          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')\n        }\n        if (Array.isArray(replacer)) {\n          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')\n        }\n      }\n      if (spacer.length !== 0) {\n        return stringifyIndent('', value, [], spacer, '')\n      }\n    }\n    return stringifySimple('', value, [])\n  }\n\n  return stringify\n}\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "export type IsStdErr = boolean;\nexport type ConsoleLogLine = [string, number, IsStdErr] | [string, number];\n\nexport type JobInputs = { [key: string]: string };\n\n// represents a way of getting a blob of data (inputs/outputs)\nexport enum DataRefType {\n  base64 = \"base64\", //default, value is a base64 encoded bytes\n  url = \"url\", // request the data at this URL\n  utf8 = \"utf8\",\n  json = \"json\",\n  // the internal system can get this data blob given the key address (stored in the value)\n  // this is typically the sha256 hash of the data\n  key = \"key\",\n}\n\nconst DataRefTypeKeys: string[] = Object.keys(DataRefType).filter((key) =>\n  isNaN(Number(key))\n);\nexport const DataRefTypesSet = new Set(DataRefTypeKeys);\nexport const DataRefTypeDefault = DataRefType.utf8;\n\nexport type DataRef<T = string> = {\n  value: T;\n  type?: DataRefType;\n  hash?: string;\n};\n\n// eslint-disable-next-line\nexport const isDataRef = (value: any): boolean => {\n  return !!(\n    value &&\n    typeof value === \"object\" &&\n    (value as DataRef)?.type &&\n    DataRefTypesSet.has((value as DataRef).type!) &&\n    (value as DataRef)?.value\n  );\n};\n\nexport type Image = string;\nexport type Command = string;\nexport type Env = { [name in string]: string } | undefined;\nexport type InputsRefs = { [name in string]: DataRef };\n// values are base64 encoded buffers\nexport type InputsBase64String = { [name in string]: string };\n\nexport type DockerJobImageBuild = {\n  context?: string;\n  filename?: string;\n  target?: string;\n  // An actual Dockerfile content\n  dockerfile?: string;\n  buildArgs?: string[];\n};\n\n// inputs values are base64 encoded strings\nexport type DockerJobDefinitionInputsBase64V1 = {\n  // version, incrementing\n  v?: number;\n  // the docker image OR git repository URL\n  image?: Image;\n  // docker image build configuration\n  build?: DockerJobImageBuild;\n  // docker command\n  command?: Command;\n  // docker env vars, not currently implemented on the client\n  env?: Env;\n  // entrypoint?: string[];\n  entrypoint?: string;\n  workdir?: string;\n  // https://docs.docker.com/engine/containers/run/#user-memory-constraints\n  shmSize?: string;\n\n  // these are dynamic\n  inputs?: InputsBase64String;\n  // these are fixed and part of the job sha\n  configFiles?: InputsBase64String;\n  durationMax?: number;\n  gpu?: boolean;\n};\n\n// as soon as the DockerJobDefinition hits the server, it is converted\n// immediately to this version, otherwise big lumps in the inputs will\n// completely clog up the data pipes. Stay small out there, definitions,\n// you're the living entities flowing\nexport type DockerJobDefinitionInputRefs =\n  & Omit<DockerJobDefinitionInputsBase64V1, \"inputs\" | \"configFiles\">\n  & {\n    inputs?: InputsRefs;\n    configFiles?: InputsRefs;\n  };\n\nexport interface DockerRunResult {\n  StatusCode?: number;\n  logs: ConsoleLogLine[];\n  // eslint-disable-next-line\n  error?: any;\n}\n\nexport interface DockerRunResultWithOutputs extends DockerRunResult {\n  outputs: InputsRefs;\n}\n\n/**\n * Think very hard and carefully before adding a new state.\n * There is a lot of power in keeping this part simple.\n */\nexport enum DockerJobState {\n  Queued = \"Queued\",\n  ReQueued = \"ReQueued\",\n  Running = \"Running\",\n  Finished = \"Finished\",\n}\n\n/**\n * Add as many as needed to help anyone understand why a job finished\n */\nexport enum DockerJobFinishedReason {\n  Cancelled = \"Cancelled\",\n  TimedOut = \"TimedOut\",\n  Success = \"Success\",\n  Error = \"Error\",\n  WorkerLost = \"WorkerLost\",\n  JobReplacedByClient = \"JobReplacedByClient\",\n}\n\nexport type DockerJobStateValue =\n  | StateChangeValueQueued\n  | StateChangeValueReQueued\n  | StateChangeValueRunning\n  | StateChangeValueFinished;\n\nexport interface StateChange {\n  // 'id' implies permanence, and you should never delete it\n  // 'tag' can be changed, when a driver for the state machine\n  // updates or takes over another processes control of the fsm process\n  tag: string;\n  state: DockerJobState;\n  job: string;\n  value: DockerJobStateValue;\n}\n/**\n * This state change contains the job definition.\n * This means history is recoverable.\n */\nexport interface StateChangeValueQueued {\n  definition: DockerJobDefinitionInputRefs;\n  time: number;\n  debug?: boolean;\n  // the client that submitted the job\n  // if there are multiple jobs from the same source,\n  // only the most recent one is kept, all others are killed\n  // TODO: handle the edge case where two different sources\n  // submit the exact same job definition. In that case, just\n  // don't kill the job unless you add a record of claimed jobs\n  // A ttl simple record would do here.\n  source?: string;\n}\n\nexport interface StateChangeValueReQueued {\n  time: number;\n}\n\nexport interface StateChangeValueRunning {\n  worker: string;\n  time: number;\n}\n\nexport interface StateChangeValueFinished {\n  result?: DockerRunResultWithOutputs;\n  reason: DockerJobFinishedReason;\n  worker?: string;\n  time: number;\n}\n\nexport interface DockerJobDefinitionRow {\n  // hash of the definition.\n  hash: string;\n  state: DockerJobState;\n  value: DockerJobStateValue;\n  history: StateChange[];\n}\n\nexport const isDockerJobDefinitionRowFinished = (\n  row: DockerJobDefinitionRow,\n) => {\n  return row.state === DockerJobState.Finished;\n};\n\nexport const getFinishedJobState = (\n  row: DockerJobDefinitionRow,\n): StateChangeValueFinished | undefined => {\n  if (isDockerJobDefinitionRowFinished(row)) {\n    return row.value as StateChangeValueFinished;\n  }\n};\n\n// export type JobsStateMap = { [id in string]: DockerJobDefinitionRow };\nexport type JobsStateMap = Record<string, DockerJobDefinitionRow>;\n\nexport interface JobStates {\n  jobs: JobsStateMap;\n}\n\nexport interface WorkerRegistration {\n  version: string;\n  id: string;\n  cpus: number;\n  gpus: number;\n  time: number;\n}\n\nexport interface WorkerStatusResponse {\n  time: number;\n  id: string;\n  cpus: number;\n  gpus: number;\n  queue: Record<string, { jobId: string; finished: boolean }>;\n}\n\nexport interface JobStatusPayload {\n  jobId: string;\n  step:\n    | \"docker image pull\"\n    | \"cloning repo\"\n    | \"docker build\"\n    | `${DockerJobState.Running}`\n    | \"docker image push\";\n  logs: ConsoleLogLine[];\n}\n\nexport interface InstanceRegistration {\n  instances: {\n    id: string;\n  }[];\n}\n\n/**\n * These are all the messsages types the worker sends to the api server\n */\nexport enum WebsocketMessageTypeWorkerToServer {\n  StateChange = \"StateChange\",\n  WorkerRegistration = \"WorkerRegistration\",\n  WorkerStatusResponse = \"WorkerStatusResponse\",\n  JobStatusLogs = \"JobStatusLogs\",\n}\nexport interface WebsocketMessageWorkerToServer {\n  type: WebsocketMessageTypeWorkerToServer;\n  payload:\n    | StateChange\n    | WorkerRegistration\n    | WorkerStatusResponse\n    | JobStatusPayload;\n}\nexport type WebsocketMessageSenderWorker = (\n  message: WebsocketMessageWorkerToServer,\n) => void;\n\n/**\n * These are all the messsages types the (browser) clients send to the api server\n */\nexport enum WebsocketMessageTypeClientToServer {\n  StateChange = \"StateChange\",\n  ClearJobCache = \"ClearJobCache\",\n  ResubmitJob = \"ResubmitJob\",\n  QueryJob = \"QueryJob\",\n}\nexport interface PayloadClearJobCache {\n  jobId: string;\n  // why do we need the definition here?\n  definition: DockerJobDefinitionInputRefs;\n}\n\nexport interface PayloadResubmitJob {\n  jobId: string;\n  // send the definition again, so we can update the state\n  // with the new definition (that may have changed the content (presigned URLS)\n  // that do not alter the hash (job id) )\n  definition: DockerJobDefinitionInputRefs;\n}\n\nexport interface PayloadClearJobCacheConfirm {\n  jobId: string;\n}\n\nexport interface PayloadClearJobOnWorker {\n  jobId: string;\n}\n\nexport interface PayloadQueryJob {\n  jobId: string;\n}\n\nexport interface WebsocketMessageClientToServer {\n  type: WebsocketMessageTypeClientToServer;\n  payload:\n    | StateChange\n    | PayloadClearJobCache\n    | PayloadResubmitJob\n    | PayloadQueryJob;\n}\nexport type WebsocketMessageSenderClient = (\n  message: WebsocketMessageClientToServer,\n) => void;\n\n/**\n * These are all the messsages types the server sends to:\n *   - the (browser) clients\n *   - the workers\n */\nexport enum WebsocketMessageTypeServerBroadcast {\n  // All jobs in the queue\n  JobStates = \"JobStates\",\n  // Updated jobs, not declarative of the entire queue\n  JobStateUpdates = \"JobStateUpdates\",\n  // logs from the worker\n  JobStatusPayload = \"JobStatusPayload\",\n  Workers = \"Workers\",\n  StatusRequest = \"StatusRequest\",\n  // Only the worker listens to this\n  ClearJobCache = \"ClearJobCache\",\n  ClearJobCacheConfirm = \"ClearJobCacheConfirm\",\n}\nexport interface WebsocketMessageServerBroadcast {\n  type: WebsocketMessageTypeServerBroadcast;\n  payload:\n    | BroadcastJobStates\n    | BroadcastJobs\n    | BroadcastWorkers\n    | BroadcastStatusRequest\n    | PayloadClearJobCacheConfirm\n    | PayloadClearJobCache\n    | JobStatusPayload;\n}\n/**\n * The job states, not the jobs themselves\n */\nexport interface BroadcastJobStates {\n  isSubset?: boolean;\n  state: JobStates;\n}\n/**\n * This doesn't contain the states, just the job definitions\n * These are just stored, the states are handled separately\n * to minimize the amount of data sent over the wire\n */\nexport interface BroadcastJobs {\n  jobs: { [key: string]: DockerJobDefinitionInputRefs };\n}\n/**\n * Let everyone know how many workers and their resources\n */\nexport interface BroadcastWorkers {\n  workers: WorkerRegistration[];\n}\n\nexport type BroadcastStatusRequest = undefined;\n\n/************************************************************\n * Client specific\n ************************************************************/\n\nexport type DockerJobDefinitionParamsInUrlHash = Omit<\n  DockerJobDefinitionInputRefs,\n  \"inputs\" | \"configInputs\"\n>;\n\n// this is the actual job definition consumed by the workers\nexport interface DockerJobDefinitionMetadata {\n  hash: string;\n  definition: DockerJobDefinitionInputRefs;\n  debug?: boolean;\n  source?: string;\n}\n\n/************************************************************\n * End Client specific\n ************************************************************/\n\n/**\n * Only Finished jobs can have the cached state deleted\n * Queued or Running jobs should not be deleted\n * @param state\n * @returns\n */\nexport const isJobCacheAllowedToBeDeleted = (state: StateChange): boolean => {\n  // This is duplicated (search for it, turn into function)\n  switch (state.state) {\n    case DockerJobState.Queued:\n    case DockerJobState.ReQueued:\n    case DockerJobState.Running:\n      // not touching the job since it's active. Finish it first.\n      return false;\n    case DockerJobState.Finished:\n      return true;\n    default:\n      return false;\n  }\n};\n\nexport type DockerApiDeviceRequest = {\n  Driver: string;\n  Count?: number;\n  DeviceIDs?: string[];\n  Capabilities: string[][];\n};\n", "import {\n  DockerJobDefinitionRow,\n  DockerJobState,\n  StateChangeValueRunning,\n} from \"./types.ts\";\nimport fetchRetry from \"fetch-retry\";\nimport { create } from \"mutative\";\nimport stringify from \"safe-stable-stringify\";\nimport equal from \"fast-deep-equal/es6\";\n\nimport { DataRef, DockerJobDefinitionInputRefs } from \"./types.ts\";\n\nconst resolvePreferredWorker = (workerA: string, workerB: string) => {\n  return workerA.localeCompare(workerB) < 0 ? workerA : workerB;\n};\n\nexport const shaDockerJob = (\n  job: DockerJobDefinitionInputRefs,\n): Promise<string> => {\n  const jobReadyForSha = create(job, (draft: DockerJobDefinitionInputRefs) => {\n    // Remove any presignedurl/... from the URLs\n    const configFiles = draft.configFiles;\n    if (configFiles) {\n      Object.keys(configFiles).forEach((key) => {\n        if (configFiles[key].type === \"url\") {\n          configFiles[key].value = reduceUrlToHashVersion(\n            (configFiles[key] as DataRef<string>)?.value,\n          );\n        }\n      });\n    }\n\n    // Remove any presignedurl/... from the URLs\n    const inputs = draft.inputs;\n    if (inputs) {\n      Object.keys(inputs).forEach((key) => {\n        if (inputs[key].type === \"url\") {\n          inputs[key].value = reduceUrlToHashVersion(\n            (inputs[key] as DataRef<string>)?.value,\n          );\n        }\n      });\n    }\n  });\n\n  return shaObject(jobReadyForSha);\n};\n\nconst reduceUrlToHashVersion = (url: string): string => {\n  if (url.includes(\"/presignedurl/\")) {\n    const tokens = url.split(\"/presignedurl/\");\n    return tokens[0];\n  }\n  if (\n    url.startsWith(\"https://metaframe-asman-test.s3.us-west-1.amazonaws.com\")\n  ) {\n    const urlBlob = new URL(url);\n    urlBlob.search = \"\";\n    urlBlob.hash = \"\";\n    return urlBlob.href;\n  }\n\n  return url;\n};\n\nexport const shaObject = (obj: any): Promise<string> => {\n  const orderedStringFromObject = stringify(obj);\n  const msgBuffer = new TextEncoder().encode(orderedStringFromObject);\n  return sha256Buffer(msgBuffer);\n};\n\nexport const sha256Buffer = async (buffer: Uint8Array): Promise<string> => {\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\n    \"\",\n  );\n  return hashHex;\n};\n\nexport const fetchRobust = fetchRetry(fetch, {\n  retries: 8,\n  // eslint-disable-next-line\n  retryDelay: (attempt: number, _error: any, _response: any) => {\n    return Math.pow(2, attempt) * 400; // 500, 1000, 2000, 4000, 5000\n  },\n  // eslint-disable-next-line\n  retryOn: (attempt: number, error: any, response: Response | null) => {\n    // retry on any network error, or 4xx or 5xx status codes\n    if (error !== null || (response && response.status >= 400)) {\n      if (attempt > 7) {\n        if (error) {\n          console.error(error);\n        }\n        console.log(\n          `Retried too many times: response.status=${response?.status} response.statusText=${response?.statusText} attempt number ${\n            attempt + 1\n          } url=${response?.url}`,\n        );\n        return false;\n      }\n      return true;\n    }\n    return false;\n  },\n});\n\n/**\n * The situation here is fluid and dynamic, workers and servers and clients coming\n * and going all the time. Rather than force some rigid single source of truth, we\n * resolve conflicts and differences as they come in, and allow jobs to be requeued.\n * This means that resolving which of two jobs is the *most correct* is critical\n * and drives a lot of the rest of the dynamics.\n * At a high level:\n *  - if a job is Finished, it trumps most things\n *  - if two jobs seem the same, the one queued first is priority\n *  - other conflicts: check the time, the earliest wins\n *  - otherwise, whoever has the longest history is priority\n */\nexport const resolveMostCorrectJob = (\n  // jobA is the DEFAULT, if that matters\n  jobA: DockerJobDefinitionRow,\n  jobB: DockerJobDefinitionRow,\n): DockerJobDefinitionRow | null => {\n  if (equal(jobA, jobB)) {\n    return jobA;\n  }\n\n  if (jobA && !jobB) {\n    return jobA;\n  }\n\n  if (!jobA && jobB) {\n    return jobB;\n  }\n\n  const jobALastChange = jobA.history[jobA.history.length - 1];\n  const isJobAFinished = jobALastChange.state === DockerJobState.Finished;\n\n  const jobBLastChange = jobB.history[jobB.history.length - 1];\n  const isJobBFinished = jobBLastChange.state === DockerJobState.Finished;\n\n  if (isJobAFinished && isJobBFinished) {\n    return jobALastChange.value.time < jobBLastChange.value.time ? jobA : jobB;\n  }\n\n  if (isJobAFinished) {\n    return jobA;\n  }\n\n  if (isJobBFinished) {\n    return jobB;\n  }\n\n  if (jobA.history.length < jobB.history.length) {\n    return jobB;\n  } else if (jobA.history.length > jobB.history.length) {\n    return jobA;\n  }\n  const jobALastEvent = jobA.history[jobA.history.length - 1];\n  const jobBLastEvent = jobB.history[jobB.history.length - 1];\n\n  if (jobALastEvent.state === jobBLastEvent.state) {\n    // If the states are equal, it depends on the state\n    switch (jobALastEvent.state) {\n      case DockerJobState.Running: {\n        const workerA = (jobALastEvent.value as StateChangeValueRunning).worker;\n        const workerB = (jobBLastEvent.value as StateChangeValueRunning).worker;\n        return resolvePreferredWorker(workerA, workerB) === workerA\n          ? jobA\n          : jobB;\n      }\n      case DockerJobState.Queued:\n      case DockerJobState.ReQueued:\n      case DockerJobState.Finished:\n      default:\n        // this is just about dates now, take the first\n        return jobALastEvent.value.time < jobBLastEvent.value.time\n          ? jobA\n          : jobB;\n    }\n  } else {\n    // They have different states? This is more complex\n    console.log(\n      `\uD83C\uDDE8\uD83C\uDDED\uD83C\uDDE8\uD83C\uDDED\uD83C\uDDE8\uD83C\uDDED \uD83C\uDF18 resolving but jobA=${jobA.state} jobB=${jobB.state}`,\n    );\n    if (jobA.state === DockerJobState.Running) {\n      return jobA;\n    } else if (jobB.state === DockerJobState.Running) {\n      return jobB;\n    }\n    return jobA.history[0].value.time < jobB.history[0].value.time\n      ? jobA\n      : jobB;\n  }\n};\n", "import { dataTypes } from './constant';\n\nexport const enum DraftType {\n  Object,\n  Array,\n  Map,\n  Set,\n}\n\nexport const Operation = {\n  Remove: 'remove',\n  Replace: 'replace',\n  Add: 'add',\n} as const;\n\nexport type DataType = keyof typeof dataTypes;\n\nexport type PatchesOptions =\n  | boolean\n  | {\n      /**\n       * The default value is `true`. If it's `true`, the path will be an array, otherwise it is a string.\n       */\n      pathAsArray?: boolean;\n      /**\n       * The default value is `true`. If it's `true`, the array length will be included in the patches, otherwise no include array length.\n       */\n      arrayLengthAssignment?: boolean;\n    };\n\nexport interface Finalities {\n  draft: ((patches?: Patches, inversePatches?: Patches) => void)[];\n  revoke: (() => void)[];\n  handledSet: WeakSet<any>;\n}\n\nexport interface ProxyDraft<T = any> {\n  type: DraftType;\n  operated?: boolean;\n  finalized: boolean;\n  original: T;\n  copy: T | null;\n  proxy: T | null;\n  finalities: Finalities;\n  options: Options<any, any> & { updatedValues?: WeakMap<any, any> };\n  parent?: ProxyDraft | null;\n  key?: string | number | symbol;\n  setMap?: Map<any, ProxyDraft>;\n  assignedMap?: Map<any, boolean>;\n  callbacks?: ((patches?: Patches, inversePatches?: Patches) => void)[];\n}\n\ninterface IPatch {\n  op: (typeof Operation)[keyof typeof Operation];\n  value?: any;\n}\n\nexport type Patch<P extends PatchesOptions = any> = P extends {\n  pathAsArray: false;\n}\n  ? IPatch & {\n      path: string;\n    }\n  : P extends true | object\n  ? IPatch & {\n      path: (string | number)[];\n    }\n  : IPatch & {\n      path: string | (string | number)[];\n    };\n\nexport type Patches<P extends PatchesOptions = any> = Patch<P>[];\n\nexport type Result<\n  T extends any,\n  O extends PatchesOptions,\n  F extends boolean\n> = O extends true | object\n  ? [F extends true ? Immutable<T> : T, Patches<O>, Patches<O>]\n  : F extends true\n  ? Immutable<T>\n  : T;\n\nexport type CreateResult<\n  T extends any,\n  O extends PatchesOptions,\n  F extends boolean,\n  R extends void | Promise<void> | T | Promise<T>\n> = R extends Promise<void> | Promise<T>\n  ? Promise<Result<T, O, F>>\n  : Result<T, O, F>;\n\ntype BaseMark = null | undefined | DataType;\ntype MarkWithCopy = BaseMark | (() => any);\n\nexport type Mark<O extends PatchesOptions, F extends boolean> = (\n  target: any,\n  types: typeof dataTypes\n) => O extends true | object\n  ? BaseMark\n  : F extends true\n  ? BaseMark\n  : MarkWithCopy;\n\nexport interface Options<O extends PatchesOptions, F extends boolean> {\n  /**\n   * In strict mode, Forbid accessing non-draftable values and forbid returning a non-draft value.\n   */\n  strict?: boolean;\n  /**\n   * Enable patch, and return the patches and inversePatches.\n   */\n  enablePatches?: O;\n  /**\n   * Enable autoFreeze, and return frozen state.\n   */\n  enableAutoFreeze?: F;\n  /**\n   * Set a mark to determine if the object is mutable or if an instance is an immutable.\n   * And it can also return a shallow copy function(AutoFreeze and Patches should both be disabled).\n   */\n  mark?: Mark<O, F>;\n}\n\nexport interface ExternalOptions<O extends PatchesOptions, F extends boolean> {\n  /**\n   * In strict mode, Forbid accessing non-draftable values and forbid returning a non-draft value.\n   */\n  strict?: boolean;\n  /**\n   * Enable patch, and return the patches and inversePatches.\n   */\n  enablePatches?: O;\n  /**\n   * Enable autoFreeze, and return frozen state.\n   */\n  enableAutoFreeze?: F;\n  /**\n   * Set a mark to determine if the object is mutable or if an instance is an immutable.\n   * And it can also return a shallow copy function(AutoFreeze and Patches should both be disabled).\n   */\n  mark?: Mark<O, F>[] | Mark<O, F>;\n}\n\n// Exclude `symbol`\ntype Primitive = string | number | bigint | boolean | null | undefined;\n\ntype ImmutableMap<K, V> = ReadonlyMap<Immutable<K>, Immutable<V>>;\ntype ImmutableSet<T> = ReadonlySet<Immutable<T>>;\ntype ImmutableObject<T> = { readonly [K in keyof T]: Immutable<T[K]> };\n\nexport type IfAvailable<T, Fallback = void> = true | false extends (\n  T extends never ? true : false\n)\n  ? Fallback\n  : keyof T extends never\n  ? Fallback\n  : T;\ntype WeakReferences =\n  | IfAvailable<WeakMap<any, any>>\n  | IfAvailable<WeakSet<any>>;\ntype AtomicObject = Function | Promise<any> | Date | RegExp;\n\nexport type Immutable<T> = T extends Primitive | AtomicObject\n  ? T\n  : T extends IfAvailable<ReadonlyMap<infer K, infer V>>\n  ? ImmutableMap<K, V>\n  : T extends IfAvailable<ReadonlySet<infer V>>\n  ? ImmutableSet<V>\n  : T extends WeakReferences\n  ? T\n  : T extends object\n  ? ImmutableObject<T>\n  : T;\n\ntype DraftedMap<K, V> = Map<K, Draft<V>>;\ntype DraftedSet<T> = Set<Draft<T>>;\ntype DraftedObject<T> = {\n  -readonly [K in keyof T]: Draft<T[K]>;\n};\n\nexport type Draft<T> = T extends Primitive | AtomicObject\n  ? T\n  : T extends IfAvailable<ReadonlyMap<infer K, infer V>>\n  ? DraftedMap<K, V>\n  : T extends IfAvailable<ReadonlySet<infer V>>\n  ? DraftedSet<V>\n  : T extends WeakReferences\n  ? T\n  : T extends object\n  ? DraftedObject<T>\n  : T;\n", "// Don't use `Symbol()` just for 3rd party access the draft\nexport const PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\nexport const RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\n\nexport const iteratorSymbol: typeof Symbol.iterator = Symbol.iterator;\n\nexport const dataTypes = {\n  mutable: 'mutable',\n  immutable: 'immutable',\n} as const;\n", "import { createDraft } from './draft';\n\nexport const internal = {} as {\n  createDraft: typeof createDraft;\n};\n", "export function has(target: object, key: PropertyKey) {\n  return target instanceof Map\n    ? target.has(key)\n    : Object.prototype.hasOwnProperty.call(target, key);\n}\n\nexport function getDescriptor(target: object, key: PropertyKey) {\n  if (key in target) {\n    let prototype = Reflect.getPrototypeOf(target);\n    while (prototype) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\n      if (descriptor) return descriptor;\n      prototype = Reflect.getPrototypeOf(prototype);\n    }\n  }\n  return;\n}\n", "import { DraftType, Mark, ProxyDraft } from '../interface';\nimport { dataTypes, PROXY_DRAFT } from '../constant';\nimport { has } from './proto';\n\nexport function latest<T = any>(proxyDraft: ProxyDraft): T {\n  return proxyDraft.copy ?? proxyDraft.original;\n}\n\n/**\n * Check if the value is a draft\n */\nexport function isDraft(target: any) {\n  return !!getProxyDraft(target);\n}\n\nexport function getProxyDraft<T extends any>(value: T): ProxyDraft | null {\n  if (typeof value !== 'object') return null;\n  return (value as { [PROXY_DRAFT]: any })?.[PROXY_DRAFT];\n}\n\nexport function getValue<T extends object>(value: T): T {\n  const proxyDraft = getProxyDraft(value);\n  return proxyDraft ? proxyDraft.copy ?? proxyDraft.original : value;\n}\n\n/**\n * Check if a value is draftable\n */\nexport function isDraftable(value: any, options?: { mark?: Mark<any, any> }) {\n  if (!value || typeof value !== 'object') return false;\n  let markResult: any;\n  return (\n    Object.getPrototypeOf(value) === Object.prototype ||\n    Array.isArray(value) ||\n    value instanceof Map ||\n    value instanceof Set ||\n    (!!options?.mark &&\n      ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\n        typeof markResult === 'function'))\n  );\n}\n\nexport function getPath(\n  target: ProxyDraft,\n  path: any[] = []\n): (string | number | object)[] | null {\n  if (Object.hasOwnProperty.call(target, 'key')) {\n    // check if the parent is a draft and the original value is not equal to the current value\n    const parentCopy = target.parent!.copy;\n    const proxyDraft = getProxyDraft(get(parentCopy, target.key!));\n    if (proxyDraft !== null && proxyDraft?.original !== target.original) {\n      return null;\n    }\n    const isSet = target.parent!.type === DraftType.Set;\n    const key = isSet\n      ? Array.from(target.parent!.setMap!.keys()).indexOf(target.key)\n      : target.key;\n    // check if the key is still in the next state parent\n    if (\n      !((isSet && parentCopy.size > (key as number)) || has(parentCopy, key!))\n    )\n      return null;\n    path.push(key);\n  }\n  if (target.parent) {\n    return getPath(target.parent, path);\n  }\n  // `target` is root draft.\n  path.reverse();\n  try {\n    // check if the path is valid\n    resolvePath(target.copy, path);\n  } catch (e) {\n    return null;\n  }\n  return path;\n}\n\nexport function getType(target: any) {\n  if (Array.isArray(target)) return DraftType.Array;\n  if (target instanceof Map) return DraftType.Map;\n  if (target instanceof Set) return DraftType.Set;\n  return DraftType.Object;\n}\n\nexport function get(target: any, key: PropertyKey) {\n  return getType(target) === DraftType.Map ? target.get(key) : target[key];\n}\n\nexport function set(target: any, key: PropertyKey, value: any) {\n  const type = getType(target);\n  if (type === DraftType.Map) {\n    target.set(key, value);\n  } else {\n    target[key] = value;\n  }\n}\n\nexport function peek(target: any, key: PropertyKey) {\n  const state = getProxyDraft(target);\n  const source = state ? latest(state) : target;\n  return source[key];\n}\n\nexport function isEqual(x: any, y: any) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nexport function revokeProxy(proxyDraft: ProxyDraft | null) {\n  if (!proxyDraft) return;\n  while (proxyDraft.finalities.revoke.length > 0) {\n    const revoke = proxyDraft.finalities.revoke.pop()!;\n    revoke();\n  }\n}\n\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\nexport function escapePath(path: string[], pathAsArray: boolean) {\n  return pathAsArray\n    ? path\n    : ['']\n        .concat(path)\n        .map((_item) => {\n          const item = `${_item}`;\n          if (item.indexOf('/') === -1 && item.indexOf('~') === -1) return item;\n          return item.replace(/~/g, '~0').replace(/\\//g, '~1');\n        })\n        .join('/');\n}\n\nexport function unescapePath(path: string | (string | number)[]) {\n  if (Array.isArray(path)) return path;\n  return path\n    .split('/')\n    .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\n    .slice(1);\n}\n\nexport function resolvePath(base: any, path: (string | number)[]) {\n  for (let index = 0; index < path.length - 1; index += 1) {\n    const key = path[index];\n    // use `index` in Set draft\n    base = get(getType(base) === DraftType.Set ? Array.from(base) : base, key);\n    if (typeof base !== 'object') {\n      throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\n    }\n  }\n  return base;\n}\n", "import type { Options, ProxyDraft } from '../interface';\nimport { dataTypes } from '../constant';\nimport { getValue, isDraft, isDraftable } from './draft';\n\nfunction strictCopy(target: any) {\n  const copy = Object.create(Object.getPrototypeOf(target));\n  Reflect.ownKeys(target).forEach((key: any) => {\n    let desc = Reflect.getOwnPropertyDescriptor(target, key)!;\n    if (desc.enumerable && desc.configurable && desc.writable) {\n      copy[key] = target[key];\n      return;\n    }\n    // for freeze\n    if (!desc.writable) {\n      desc.writable = true;\n      desc.configurable = true;\n    }\n    if (desc.get || desc.set)\n      desc = {\n        configurable: true,\n        writable: true,\n        enumerable: desc.enumerable,\n        value: target[key],\n      };\n    Reflect.defineProperty(copy, key, desc);\n  });\n  return copy;\n}\n\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\n\nexport function shallowCopy(original: any, options?: Options<any, any>) {\n  let markResult: any;\n  if (Array.isArray(original)) {\n    return Array.prototype.concat.call(original);\n  } else if (original instanceof Set) {\n    return new Set(original.values());\n  } else if (original instanceof Map) {\n    return new Map(original);\n  } else if (\n    options?.mark &&\n    ((markResult = options.mark(original, dataTypes)),\n    markResult !== undefined) &&\n    markResult !== dataTypes.mutable\n  ) {\n    if (markResult === dataTypes.immutable) {\n      return strictCopy(original);\n    } else if (typeof markResult === 'function') {\n      if (__DEV__ && (options.enablePatches || options.enableAutoFreeze)) {\n        throw new Error(\n          `You can't use mark and patches or auto freeze together.`\n        );\n      }\n      return markResult();\n    }\n    throw new Error(`Unsupported mark result: ${markResult}`);\n  } else if (\n    typeof original === 'object' &&\n    Object.getPrototypeOf(original) === Object.prototype\n  ) {\n    // For best performance with shallow copies,\n    // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\n    const copy: Record<string | symbol, any> = {};\n    Object.keys(original).forEach((key) => {\n      copy[key] = original[key];\n    });\n    Object.getOwnPropertySymbols(original).forEach((key) => {\n      if (propIsEnum.call(original, key)) {\n        copy[key] = original[key];\n      }\n    });\n    return copy;\n  } else {\n    throw new Error(\n      `Please check mark() to ensure that it is a stable marker draftable function.`\n    );\n  }\n}\n\nexport function ensureShallowCopy(target: ProxyDraft) {\n  if (target.copy) return;\n  target.copy = shallowCopy(target.original, target.options)!;\n}\n\nfunction deepClone<T>(target: T): T;\nfunction deepClone(target: any) {\n  if (!isDraftable(target)) return getValue(target);\n  if (Array.isArray(target)) return target.map(deepClone);\n  if (target instanceof Map)\n    return new Map(\n      Array.from(target.entries()).map(([k, v]) => [k, deepClone(v)])\n    );\n  if (target instanceof Set) return new Set(Array.from(target).map(deepClone));\n  const copy = Object.create(Object.getPrototypeOf(target));\n  for (const key in target) copy[key] = deepClone(target[key]);\n  return copy;\n}\n\nexport function cloneIfNeeded<T>(target: T): T {\n  return isDraft(target) ? deepClone(target) : target;\n}\n\nexport { deepClone };\n", "import { ProxyDraft } from '../interface';\n\nexport function markChanged(proxyDraft: ProxyDraft) {\n  proxyDraft.assignedMap = proxyDraft.assignedMap ?? new Map();\n  if (!proxyDraft.operated) {\n    proxyDraft.operated = true;\n    if (proxyDraft.parent) {\n      markChanged(proxyDraft.parent);\n    }\n  }\n}\n", "import { DraftType } from '../interface';\nimport { getType, isDraft } from './draft';\n\nfunction throwFrozenError() {\n  throw new Error('Cannot modify frozen object');\n}\n\nfunction isFreezable(value: any) {\n  return (\n    __DEV__ || (value && typeof value === 'object' && !Object.isFrozen(value))\n  );\n}\n\nexport function deepFreeze(\n  target: any,\n  subKey?: any,\n  updatedValues?: WeakMap<any, any>,\n  stack?: any[],\n  keys?: any[]\n) {\n  if (__DEV__) {\n    updatedValues = updatedValues ?? new WeakMap();\n    stack = stack ?? [];\n    keys = keys ?? [];\n    const value = updatedValues.has(target)\n      ? updatedValues.get(target)\n      : target;\n    if (stack.length > 0) {\n      const index = stack.indexOf(value);\n      if (value && typeof value === 'object' && index !== -1) {\n        if (stack[0] === value) {\n          throw new Error(`Forbids circular reference`);\n        }\n        throw new Error(\n          `Forbids circular reference: ~/${keys\n            .slice(0, index)\n            .map((key, index) => {\n              if (typeof key === 'symbol') return `[${key.toString()}]`;\n              const parent = stack![index];\n              if (\n                typeof key === 'object' &&\n                (parent instanceof Map || parent instanceof Set)\n              )\n                return Array.from(parent.keys()).indexOf(key);\n              return key;\n            })\n            .join('/')}`\n        );\n      }\n      stack.push(value);\n      keys.push(subKey);\n    } else {\n      stack.push(value);\n    }\n  }\n  if (Object.isFrozen(target) || isDraft(target)) {\n    if (__DEV__) {\n      stack!.pop();\n      keys!.pop();\n    }\n    return;\n  }\n  const type = getType(target);\n  switch (type) {\n    case DraftType.Map:\n      for (const [key, value] of target) {\n        if (isFreezable(key)) deepFreeze(key, key, updatedValues, stack, keys);\n        if (isFreezable(value))\n          deepFreeze(value, key, updatedValues, stack, keys);\n      }\n      target.set = target.clear = target.delete = throwFrozenError;\n      break;\n    case DraftType.Set:\n      for (const value of target) {\n        if (isFreezable(value))\n          deepFreeze(value, value, updatedValues, stack, keys);\n      }\n      target.add = target.clear = target.delete = throwFrozenError;\n      break;\n    case DraftType.Array:\n      Object.freeze(target);\n      let index = 0;\n      for (const value of target) {\n        if (isFreezable(value))\n          deepFreeze(value, index, updatedValues, stack, keys);\n        index += 1;\n      }\n      break;\n    default:\n      Object.freeze(target);\n      // ignore non-enumerable or symbol properties\n      Object.keys(target).forEach((name) => {\n        const value = target[name];\n        if (isFreezable(value))\n          deepFreeze(value, name, updatedValues, stack, keys);\n      });\n  }\n  if (__DEV__) {\n    stack!.pop();\n    keys!.pop();\n  }\n}\n", "import { DraftType } from '../interface';\nimport { getType } from './draft';\n\nexport function forEach<T extends object>(\n  target: T,\n  iter: (key: string | number | symbol, value: any, source: T) => void\n) {\n  const type = getType(target);\n  if (type === DraftType.Object) {\n    Reflect.ownKeys(target).forEach((key) => {\n      iter(key, (target as any)[key], target);\n    });\n  } else if (type === DraftType.Array) {\n    let index = 0;\n    for (const entry of target as any[]) {\n      iter(index, entry, target);\n      index += 1;\n    }\n  } else {\n    (target as Map<any, any> | Set<any>).forEach((entry: any, index: any) =>\n      iter(index, entry, target)\n    );\n  }\n}\n", "import { DraftType, Patches, ProxyDraft } from '../interface';\nimport { ensureShallowCopy } from './copy';\nimport {\n  get,\n  getPath,\n  getProxyDraft,\n  getValue,\n  isDraft,\n  isDraftable,\n  isEqual,\n  set,\n} from './draft';\nimport { forEach } from './forEach';\n\nexport function handleValue(\n  target: any,\n  handledSet: WeakSet<any>,\n  options?: ProxyDraft['options']\n) {\n  if (\n    isDraft(target) ||\n    !isDraftable(target, options) ||\n    handledSet.has(target) ||\n    Object.isFrozen(target)\n  )\n    return;\n  const isSet = target instanceof Set;\n  const setMap: Map<any, any> | undefined = isSet ? new Map() : undefined;\n  handledSet.add(target);\n  forEach(target, (key, value) => {\n    if (isDraft(value)) {\n      const proxyDraft = getProxyDraft(value)!;\n      ensureShallowCopy(proxyDraft);\n      // A draft where a child node has been changed, or assigned a value\n      const updatedValue =\n        proxyDraft.assignedMap?.size || proxyDraft.operated\n          ? proxyDraft.copy\n          : proxyDraft.original;\n      // final update value\n      set(isSet ? setMap! : target, key, updatedValue);\n    } else {\n      handleValue(value, handledSet, options);\n    }\n  });\n  if (setMap) {\n    const set = target as Set<any>;\n    const values = Array.from(set);\n    set.clear();\n    values.forEach((value) => {\n      set.add(setMap!.has(value) ? setMap!.get(value) : value);\n    });\n  }\n}\n\nexport function finalizeAssigned(proxyDraft: ProxyDraft, key: PropertyKey) {\n  // handle the draftable assigned values\uFF0C and the value is not a draft\n  const copy =\n    proxyDraft.type === DraftType.Set ? proxyDraft.setMap : proxyDraft.copy;\n  if (\n    proxyDraft.finalities.revoke.length > 1 &&\n    proxyDraft.assignedMap!.get(key) &&\n    copy\n  ) {\n    handleValue(\n      get(copy, key),\n      proxyDraft.finalities.handledSet,\n      proxyDraft.options\n    );\n  }\n}\n\nexport type GeneratePatches = (\n  proxyState: ProxyDraft,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches\n) => void;\n\nexport function finalizeSetValue(target: ProxyDraft) {\n  if (target.type === DraftType.Set && target.copy) {\n    target.copy.clear();\n    target.setMap!.forEach((value) => {\n      target.copy!.add(getValue(value));\n    });\n  }\n}\n\nexport function finalizePatches(\n  target: ProxyDraft,\n  generatePatches: GeneratePatches,\n  patches?: Patches,\n  inversePatches?: Patches\n) {\n  const shouldFinalize =\n    target.operated &&\n    target.assignedMap &&\n    target.assignedMap.size > 0 &&\n    !target.finalized;\n  if (shouldFinalize) {\n    if (patches && inversePatches) {\n      const basePath = getPath(target);\n      if (basePath) {\n        generatePatches(target, basePath, patches, inversePatches);\n      }\n    }\n    target.finalized = true;\n  }\n}\n\nexport function markFinalization(\n  target: ProxyDraft,\n  key: any,\n  value: any,\n  generatePatches: GeneratePatches\n) {\n  const proxyDraft = getProxyDraft(value);\n  if (proxyDraft) {\n    // !case: assign the draft value\n    if (!proxyDraft.callbacks) {\n      proxyDraft.callbacks = [];\n    }\n    proxyDraft.callbacks.push((patches, inversePatches) => {\n      const copy = target.type === DraftType.Set ? target.setMap : target.copy;\n      if (isEqual(get(copy, key), value)) {\n        let updatedValue = proxyDraft.original;\n        if (proxyDraft.copy) {\n          updatedValue = proxyDraft.copy;\n        }\n        finalizeSetValue(target);\n        finalizePatches(target, generatePatches, patches, inversePatches);\n        if (__DEV__ && target.options.enableAutoFreeze) {\n          target.options.updatedValues =\n            target.options.updatedValues ?? new WeakMap();\n          target.options.updatedValues.set(updatedValue, proxyDraft.original);\n        }\n        // final update value\n        set(copy, key, updatedValue);\n      }\n    });\n    if (target.options.enableAutoFreeze) {\n      // !case: assign the draft value in cross draft tree\n      if (proxyDraft.finalities !== target.finalities) {\n        target.options.enableAutoFreeze = false;\n      }\n    }\n  }\n  if (isDraftable(value, target.options)) {\n    // !case: assign the non-draft value\n    target.finalities.draft.push(() => {\n      const copy = target.type === DraftType.Set ? target.setMap : target.copy;\n      if (isEqual(get(copy, key), value)) {\n        finalizeAssigned(target, key);\n      }\n    });\n  }\n}\n", "import { DraftType, Operation, Patches, ProxyDraft } from './interface';\nimport { cloneIfNeeded, escapePath, get, has, isEqual } from './utils';\n\nfunction generateArrayPatches(\n  proxyState: ProxyDraft<Array<any>>,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches,\n  pathAsArray: boolean\n) {\n  let { original, assignedMap, options } = proxyState;\n  let copy = proxyState.copy!;\n  if (copy.length < original.length) {\n    [original, copy] = [copy, original];\n    [patches, inversePatches] = [inversePatches, patches];\n  }\n  for (let index = 0; index < original.length; index += 1) {\n    if (assignedMap!.get(index.toString()) && copy[index] !== original[index]) {\n      const _path = basePath.concat([index]);\n      const path = escapePath(_path, pathAsArray);\n      patches.push({\n        op: Operation.Replace,\n        path,\n        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n        value: cloneIfNeeded(copy[index]),\n      });\n      inversePatches.push({\n        op: Operation.Replace,\n        path,\n        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n        value: cloneIfNeeded(original[index]),\n      });\n    }\n  }\n  for (let index = original.length; index < copy.length; index += 1) {\n    const _path = basePath.concat([index]);\n    const path = escapePath(_path, pathAsArray);\n    patches.push({\n      op: Operation.Add,\n      path,\n      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n      value: cloneIfNeeded(copy[index]),\n    });\n  }\n  if (original.length < copy.length) {\n    // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\n    // For performance, here we only generate an operation that replaces the length of the array,\n    // which is inconsistent with JSON Patch specification\n    const { arrayLengthAssignment = true } = options.enablePatches;\n    if (arrayLengthAssignment) {\n      const _path = basePath.concat(['length']);\n      const path = escapePath(_path, pathAsArray);\n      inversePatches.push({\n        op: Operation.Replace,\n        path,\n        value: original.length,\n      });\n    } else {\n      for (let index = copy.length; original.length < index; index -= 1) {\n        const _path = basePath.concat([index - 1]);\n        const path = escapePath(_path, pathAsArray);\n        inversePatches.push({\n          op: Operation.Remove,\n          path,\n        });\n      }\n    }\n  }\n}\n\nfunction generatePatchesFromAssigned(\n  { original, copy, assignedMap }: ProxyDraft<Record<string, any>>,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches,\n  pathAsArray: boolean\n) {\n  assignedMap!.forEach((assignedValue, key) => {\n    const originalValue = get(original, key);\n    const value = cloneIfNeeded(get(copy, key));\n    const op = !assignedValue\n      ? Operation.Remove\n      : has(original, key)\n      ? Operation.Replace\n      : Operation.Add;\n    if (isEqual(originalValue, value) && op === Operation.Replace) return;\n    const _path = basePath.concat(key);\n    const path = escapePath(_path, pathAsArray);\n    patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\n    inversePatches.push(\n      op === Operation.Add\n        ? { op: Operation.Remove, path }\n        : op === Operation.Remove\n        ? { op: Operation.Add, path, value: originalValue }\n        : { op: Operation.Replace, path, value: originalValue }\n    );\n  });\n}\n\nfunction generateSetPatches(\n  { original, copy }: ProxyDraft<Set<any>>,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches,\n  pathAsArray: boolean\n) {\n  let index = 0;\n  original.forEach((value: any) => {\n    if (!copy!.has(value)) {\n      const _path = basePath.concat([index]);\n      const path = escapePath(_path, pathAsArray);\n      patches.push({\n        op: Operation.Remove,\n        path,\n        value,\n      });\n      inversePatches.unshift({\n        op: Operation.Add,\n        path,\n        value,\n      });\n    }\n    index += 1;\n  });\n  index = 0;\n  copy!.forEach((value: any) => {\n    if (!original.has(value)) {\n      const _path = basePath.concat([index]);\n      const path = escapePath(_path, pathAsArray);\n      patches.push({\n        op: Operation.Add,\n        path,\n        value,\n      });\n      inversePatches.unshift({\n        op: Operation.Remove,\n        path,\n        value,\n      });\n    }\n    index += 1;\n  });\n}\n\nexport function generatePatches(\n  proxyState: ProxyDraft,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches\n) {\n  const { pathAsArray = true } = proxyState.options.enablePatches;\n  switch (proxyState.type) {\n    case DraftType.Object:\n    case DraftType.Map:\n      return generatePatchesFromAssigned(\n        proxyState,\n        basePath,\n        patches,\n        inversePatches,\n        pathAsArray\n      );\n    case DraftType.Array:\n      return generateArrayPatches(\n        proxyState,\n        basePath,\n        patches,\n        inversePatches,\n        pathAsArray\n      );\n    case DraftType.Set:\n      return generateSetPatches(\n        proxyState,\n        basePath,\n        patches,\n        inversePatches,\n        pathAsArray\n      );\n  }\n}\n", "import { Options } from './interface';\nimport { isDraftable } from './utils';\n\nlet readable = false;\n\nexport const checkReadable = (\n  value: any,\n  options: Options<any, any>,\n  ignoreCheckDraftable = false\n) => {\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    (!isDraftable(value, options) || ignoreCheckDraftable) &&\n    !readable\n  ) {\n    throw new Error(\n      `Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`\n    );\n  }\n};\n\n/**\n * `unsafe(callback)` to access mutable data directly in strict mode.\n *\n * ## Example\n *\n * ```ts\n * import { create, unsafe } from '../index';\n *\n * class Foobar {\n *   bar = 1;\n * }\n *\n * const baseState = { foobar: new Foobar() };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *    unsafe(() => {\n *      draft.foobar.bar = 2;\n *    });\n *   },\n *   {\n *     strict: true,\n *   }\n * );\n *\n * expect(state).toBe(baseState);\n * expect(state.foobar).toBe(baseState.foobar);\n * expect(state.foobar.bar).toBe(2);\n * ```\n */\nexport function unsafe<T>(callback: () => T): T {\n  readable = true;\n  let result: T;\n  try {\n    result = callback();\n  } finally {\n    readable = false;\n  }\n  return result;\n}\n", "import { dataTypes, iteratorSymbol } from './constant';\nimport { internal } from './internal';\nimport { generatePatches } from './patch';\nimport { checkReadable } from './unsafe';\nimport {\n  ensureShallowCopy,\n  getProxyDraft,\n  isDraftable,\n  isEqual,\n  latest,\n  markChanged,\n  markFinalization,\n} from './utils';\n\nexport const mapHandler = {\n  get size() {\n    const current: Map<any, any> = latest(getProxyDraft(this)!);\n    return current.size;\n  },\n  has(key: any): boolean {\n    return latest(getProxyDraft(this)!).has(key);\n  },\n  set(key: any, value: any) {\n    const target = getProxyDraft(this)!;\n    const source = latest(target);\n    if (!source.has(key) || !isEqual(source.get(key), value)) {\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap!.set(key, true);\n      target.copy.set(key, value);\n      markFinalization(target, key, value, generatePatches);\n    }\n    return this;\n  },\n  delete(key: any): boolean {\n    if (!this.has(key)) {\n      return false;\n    }\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    markChanged(target);\n    if (target.original.has(key)) {\n      target.assignedMap!.set(key, false);\n    } else {\n      target.assignedMap!.delete(key);\n    }\n    target.copy.delete(key);\n    return true;\n  },\n  clear() {\n    const target = getProxyDraft(this)!;\n    if (!this.size) return;\n    ensureShallowCopy(target);\n    markChanged(target);\n    target.assignedMap = new Map();\n    for (const [key] of target.original) {\n      target.assignedMap.set(key, false);\n    }\n    target.copy!.clear();\n  },\n  forEach(callback: (value: any, key: any, self: any) => void, thisArg?: any) {\n    const target = getProxyDraft(this)!;\n    latest(target).forEach((_value: any, _key: any) => {\n      callback.call(thisArg, this.get(_key), _key, this);\n    });\n  },\n  get(key: any): any {\n    const target = getProxyDraft(this)!;\n    const value = latest(target).get(key);\n    const mutable =\n      target.options.mark?.(value, dataTypes) === dataTypes.mutable;\n    if (target.options.strict) {\n      checkReadable(value, target.options, mutable);\n    }\n    if (mutable) {\n      return value;\n    }\n    if (target.finalized || !isDraftable(value, target.options)) {\n      return value;\n    }\n    // drafted or reassigned\n    if (value !== target.original.get(key)) {\n      return value;\n    }\n    const draft = internal.createDraft({\n      original: value,\n      parentDraft: target,\n      key,\n      finalities: target.finalities,\n      options: target.options,\n    });\n    ensureShallowCopy(target);\n    target.copy.set(key, draft);\n    return draft;\n  },\n  keys(): IterableIterator<any> {\n    return latest(getProxyDraft(this)!).keys();\n  },\n  values(): IterableIterator<any> {\n    const iterator = this.keys();\n    return {\n      [iteratorSymbol]: () => this.values(),\n      next: () => {\n        const result = iterator.next();\n        if (result.done) return result;\n        const value = this.get(result.value);\n        return {\n          done: false,\n          value,\n        };\n      },\n    } as any;\n  },\n  entries(): IterableIterator<[any, any]> {\n    const iterator = this.keys();\n    return {\n      [iteratorSymbol]: () => this.entries(),\n      next: () => {\n        const result = iterator.next();\n        if (result.done) return result;\n        const value = this.get(result.value);\n        return {\n          done: false,\n          value: [result.value, value],\n        };\n      },\n    } as any;\n  },\n  [iteratorSymbol]() {\n    return this.entries();\n  },\n};\n\nexport const mapHandlerKeys = Reflect.ownKeys(mapHandler);\n", "import { ProxyDraft } from './interface';\nimport { dataTypes, iteratorSymbol } from './constant';\nimport { internal } from './internal';\nimport {\n  ensureShallowCopy,\n  getProxyDraft,\n  isDraftable,\n  markChanged,\n  markFinalization,\n} from './utils';\nimport { checkReadable } from './unsafe';\nimport { generatePatches } from './patch';\n\nconst getNextIterator =\n  (\n    target: ProxyDraft<any>,\n    iterator: IterableIterator<any>,\n    { isValuesIterator }: { isValuesIterator: boolean }\n  ) =>\n  () => {\n    const result = iterator.next();\n    if (result.done) return result;\n    const key = result.value as any;\n    let value = target.setMap!.get(key);\n    const currentDraft = getProxyDraft(value);\n    const mutable =\n      target.options.mark?.(value, dataTypes) === dataTypes.mutable;\n    if (target.options.strict) {\n      checkReadable(key, target.options, mutable);\n    }\n    if (\n      !mutable &&\n      !currentDraft &&\n      isDraftable(key, target.options) &&\n      !target.finalized &&\n      target.original!.has(key)\n    ) {\n      // draft a draftable original set item\n      const proxy = internal.createDraft({\n        original: key,\n        parentDraft: target,\n        key,\n        finalities: target.finalities,\n        options: target.options,\n      });\n      target.setMap!.set(key, proxy);\n      value = proxy;\n    } else if (currentDraft) {\n      // drafted\n      value = currentDraft.proxy;\n    }\n    return {\n      done: false,\n      value: isValuesIterator ? value : [value, value],\n    };\n  };\n\nexport const setHandler = {\n  get size() {\n    const target: ProxyDraft<any> = getProxyDraft(this)!;\n    return target.setMap!.size;\n  },\n  has(value: any) {\n    const target = getProxyDraft(this)!;\n    // reassigned or non-draftable values\n    if (target.setMap!.has(value)) return true;\n    ensureShallowCopy(target);\n    const valueProxyDraft = getProxyDraft(value)!;\n    // drafted\n    if (valueProxyDraft && target.setMap!.has(valueProxyDraft.original))\n      return true;\n    return false;\n  },\n  add(value: any) {\n    const target = getProxyDraft(this)!;\n    if (!this.has(value)) {\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap!.set(value, true);\n      target.setMap!.set(value, value);\n      markFinalization(target, value, value, generatePatches);\n    }\n    return this;\n  },\n  delete(value: any): boolean {\n    if (!this.has(value)) {\n      return false;\n    }\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    markChanged(target);\n    const valueProxyDraft = getProxyDraft(value)!;\n    if (valueProxyDraft && target.setMap!.has(valueProxyDraft.original)) {\n      // delete drafted\n      target.assignedMap!.set(valueProxyDraft.original, false);\n      return target.setMap!.delete(valueProxyDraft.original);\n    }\n    if (!valueProxyDraft && target.setMap!.has(value)) {\n      // non-draftable values\n      target.assignedMap!.set(value, false);\n    } else {\n      // reassigned\n      target.assignedMap!.delete(value);\n    }\n    // delete reassigned or non-draftable values\n    return target.setMap!.delete(value);\n  },\n  clear() {\n    if (!this.size) return;\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    markChanged(target);\n    for (const value of target.original) {\n      target.assignedMap!.set(value, false);\n    }\n    target.setMap!.clear();\n  },\n  values(): IterableIterator<any> {\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    const iterator = target.setMap!.keys();\n    return {\n      [Symbol.iterator]: () => this.values(),\n      next: getNextIterator(target, iterator, { isValuesIterator: true }),\n    };\n  },\n  entries(): IterableIterator<[any, any]> {\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    const iterator = target.setMap!.keys();\n    return {\n      [Symbol.iterator]: () => this.entries(),\n      next: getNextIterator(target, iterator, {\n        isValuesIterator: false,\n      }) as () => IteratorReturnResult<any>,\n    };\n  },\n  keys(): IterableIterator<any> {\n    return this.values();\n  },\n  [iteratorSymbol]() {\n    return this.values();\n  },\n  forEach(callback: any, thisArg?: any) {\n    const iterator = this.values();\n    let result = iterator.next();\n    while (!result.done) {\n      callback.call(thisArg, result.value, result.value, this);\n      result = iterator.next();\n    }\n  },\n};\n\nexport const setHandlerKeys = Reflect.ownKeys(setHandler);\n", "import {\n  DraftType,\n  Finalities,\n  Patches,\n  ProxyDraft,\n  Options,\n  Operation,\n} from './interface';\nimport { dataTypes, PROXY_DRAFT } from './constant';\nimport { mapHandler, mapHandlerKeys } from './map';\nimport { setHandler, setHandlerKeys } from './set';\nimport { internal } from './internal';\nimport {\n  deepFreeze,\n  ensureShallowCopy,\n  getDescriptor,\n  getProxyDraft,\n  getType,\n  getValue,\n  has,\n  isEqual,\n  isDraftable,\n  latest,\n  markChanged,\n  peek,\n  get,\n  set,\n  revokeProxy,\n  finalizeSetValue,\n  markFinalization,\n  finalizePatches,\n} from './utils';\nimport { checkReadable } from './unsafe';\nimport { generatePatches } from './patch';\n\nconst draftsCache = new WeakSet<object>();\n\nconst proxyHandler: ProxyHandler<ProxyDraft> = {\n  get(target: ProxyDraft, key: string | number | symbol, receiver: any) {\n    const copy = target.copy?.[key];\n    // Improve draft reading performance by caching the draft copy.\n    if (copy && draftsCache.has(copy)) {\n      return copy;\n    }\n    if (key === PROXY_DRAFT) return target;\n    let markResult: any;\n    if (target.options.mark) {\n      // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\n      // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\n      const value =\n        key === 'size' &&\n        (target.original instanceof Map || target.original instanceof Set)\n          ? Reflect.get(target.original, key)\n          : Reflect.get(target.original, key, receiver);\n      markResult = target.options.mark(value, dataTypes);\n      if (markResult === dataTypes.mutable) {\n        if (target.options.strict) {\n          checkReadable(value, target.options, true);\n        }\n        return value;\n      }\n    }\n    const source = latest(target);\n\n    if (source instanceof Map && mapHandlerKeys.includes(key as any)) {\n      if (key === 'size') {\n        return Object.getOwnPropertyDescriptor(mapHandler, 'size')!.get!.call(\n          target.proxy\n        );\n      }\n      const handle = mapHandler[key as keyof typeof mapHandler] as Function;\n      if (handle) {\n        return handle.bind(target.proxy);\n      }\n    }\n\n    if (source instanceof Set && setHandlerKeys.includes(key as any)) {\n      if (key === 'size') {\n        return Object.getOwnPropertyDescriptor(setHandler, 'size')!.get!.call(\n          target.proxy\n        );\n      }\n      const handle = setHandler[key as keyof typeof setHandler] as Function;\n      if (handle) {\n        return handle.bind(target.proxy);\n      }\n    }\n\n    if (!has(source, key)) {\n      const desc = getDescriptor(source, key);\n      return desc\n        ? `value` in desc\n          ? desc.value\n          : // !case: support for getter\n            desc.get?.call(target.proxy)\n        : undefined;\n    }\n    const value = source[key];\n    if (target.options.strict) {\n      checkReadable(value, target.options);\n    }\n    if (target.finalized || !isDraftable(value, target.options)) {\n      return value;\n    }\n    // Ensure that the assigned values are not drafted\n    if (value === peek(target.original, key)) {\n      ensureShallowCopy(target);\n      target.copy![key] = createDraft({\n        original: target.original[key],\n        parentDraft: target,\n        key: target.type === DraftType.Array ? Number(key) : key,\n        finalities: target.finalities,\n        options: target.options,\n      });\n      // !case: support for custom shallow copy function\n      if (typeof markResult === 'function') {\n        const subProxyDraft = getProxyDraft(target.copy![key])!;\n        ensureShallowCopy(subProxyDraft);\n        // Trigger a custom shallow copy to update to a new copy\n        markChanged(subProxyDraft);\n        return subProxyDraft.copy;\n      }\n      return target.copy![key];\n    }\n    return value;\n  },\n  set(target: ProxyDraft, key: string | number | symbol, value: any) {\n    if (target.type === DraftType.Set || target.type === DraftType.Map) {\n      throw new Error(\n        `Map/Set draft does not support any property assignment.`\n      );\n    }\n    let _key: number;\n    if (\n      target.type === DraftType.Array &&\n      key !== 'length' &&\n      !(\n        Number.isInteger((_key = Number(key))) &&\n        _key >= 0 &&\n        (key === 0 || _key === 0 || String(_key) === String(key))\n      )\n    ) {\n      throw new Error(\n        `Only supports setting array indices and the 'length' property.`\n      );\n    }\n    const desc = getDescriptor(latest(target), key);\n    if (desc?.set) {\n      // !case: cover the case of setter\n      desc.set.call(target.proxy, value);\n      return true;\n    }\n    const current = peek(latest(target), key);\n    const currentProxyDraft = getProxyDraft(current);\n    if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n      // !case: ignore the case of assigning the original draftable value to a draft\n      target.copy![key] = value;\n      target.assignedMap = target.assignedMap ?? new Map();\n      target.assignedMap.set(key, false);\n      return true;\n    }\n    // !case: handle new props with value 'undefined'\n    if (\n      isEqual(value, current) &&\n      (value !== undefined || has(target.original, key))\n    )\n      return true;\n    ensureShallowCopy(target);\n    markChanged(target);\n    if (has(target.original, key) && isEqual(value, target.original[key])) {\n      // !case: handle the case of assigning the original non-draftable value to a draft\n      target.assignedMap!.delete(key);\n    } else {\n      target.assignedMap!.set(key, true);\n    }\n    target.copy![key] = value;\n    markFinalization(target, key, value, generatePatches);\n    return true;\n  },\n  has(target: ProxyDraft, key: string | symbol) {\n    return key in latest(target);\n  },\n  ownKeys(target: ProxyDraft) {\n    return Reflect.ownKeys(latest(target));\n  },\n  getOwnPropertyDescriptor(target: ProxyDraft, key: string | symbol) {\n    const source = latest(target);\n    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n    if (!descriptor) return descriptor;\n    return {\n      writable: true,\n      configurable: target.type !== DraftType.Array || key !== 'length',\n      enumerable: descriptor.enumerable,\n      value: source[key],\n    };\n  },\n  getPrototypeOf(target: ProxyDraft) {\n    return Reflect.getPrototypeOf(target.original);\n  },\n  setPrototypeOf() {\n    throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\n  },\n  defineProperty() {\n    throw new Error(`Cannot call 'defineProperty()' on drafts`);\n  },\n  deleteProperty(target: ProxyDraft, key: string | symbol) {\n    if (target.type === DraftType.Array) {\n      return proxyHandler.set!.call(this, target, key, undefined, target.proxy);\n    }\n    if (peek(target.original, key) !== undefined || key in target.original) {\n      // !case: delete an existing key\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap!.set(key, false);\n    } else {\n      target.assignedMap = target.assignedMap ?? new Map();\n      // The original non-existent key has been deleted\n      target.assignedMap.delete(key);\n    }\n    if (target.copy) delete target.copy[key];\n    return true;\n  },\n};\n\nexport function createDraft<T extends object>(createDraftOptions: {\n  original: T;\n  parentDraft?: ProxyDraft | null;\n  key?: string | number | symbol;\n  finalities: Finalities;\n  options: Options<any, any>;\n}): T {\n  const { original, parentDraft, key, finalities, options } =\n    createDraftOptions;\n  const type = getType(original);\n  const proxyDraft: ProxyDraft = {\n    type,\n    finalized: false,\n    parent: parentDraft,\n    original,\n    copy: null,\n    proxy: null,\n    finalities,\n    options,\n    // Mapping of draft Set items to their corresponding draft values.\n    setMap:\n      type === DraftType.Set\n        ? new Map((original as Set<any>).entries())\n        : undefined,\n  };\n  // !case: undefined as a draft map key\n  if (key || 'key' in createDraftOptions) {\n    proxyDraft.key = key;\n  }\n  const { proxy, revoke } = Proxy.revocable<any>(\n    type === DraftType.Array ? Object.assign([], proxyDraft) : proxyDraft,\n    proxyHandler\n  );\n  finalities.revoke.push(revoke);\n  draftsCache.add(proxy);\n  proxyDraft.proxy = proxy;\n  if (parentDraft) {\n    const target = parentDraft;\n    target.finalities.draft.push((patches, inversePatches) => {\n      const oldProxyDraft = getProxyDraft(proxy)!;\n      // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\n      let copy = target.type === DraftType.Set ? target.setMap : target.copy;\n      const draft = get(copy, key!);\n      const proxyDraft = getProxyDraft(draft);\n      if (proxyDraft) {\n        // assign the updated value to the copy object\n        let updatedValue = proxyDraft.original;\n        if (proxyDraft.operated) {\n          updatedValue = getValue(draft);\n        }\n        finalizeSetValue(proxyDraft);\n        finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n        if (__DEV__ && target.options.enableAutoFreeze) {\n          target.options.updatedValues =\n            target.options.updatedValues ?? new WeakMap();\n          target.options.updatedValues.set(updatedValue, proxyDraft.original);\n        }\n        // final update value\n        set(copy, key!, updatedValue);\n      }\n      // !case: handle the deleted key\n      oldProxyDraft.callbacks?.forEach((callback) => {\n        callback(patches, inversePatches);\n      });\n    });\n  } else {\n    // !case: handle the root draft\n    const target = getProxyDraft(proxy)!;\n    target.finalities.draft.push((patches, inversePatches) => {\n      finalizeSetValue(target);\n      finalizePatches(target, generatePatches, patches, inversePatches);\n    });\n  }\n  return proxy;\n}\n\ninternal.createDraft = createDraft;\n\nexport function finalizeDraft<T>(\n  result: T,\n  returnedValue: [T] | [],\n  patches?: Patches,\n  inversePatches?: Patches,\n  enableAutoFreeze?: boolean\n) {\n  const proxyDraft = getProxyDraft(result);\n  const original = proxyDraft?.original ?? result;\n  const hasReturnedValue = !!returnedValue.length;\n  if (proxyDraft?.operated) {\n    while (proxyDraft.finalities.draft.length > 0) {\n      const finalize = proxyDraft.finalities.draft.pop()!;\n      finalize(patches, inversePatches);\n    }\n  }\n  const state = hasReturnedValue\n    ? returnedValue[0]\n    : proxyDraft\n    ? proxyDraft.operated\n      ? proxyDraft.copy\n      : proxyDraft.original\n    : result;\n  if (proxyDraft) revokeProxy(proxyDraft);\n  if (enableAutoFreeze) {\n    deepFreeze(state, state, proxyDraft?.options.updatedValues);\n  }\n  return [\n    state,\n    patches && hasReturnedValue\n      ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\n      : patches,\n    inversePatches && hasReturnedValue\n      ? [{ op: Operation.Replace, path: [], value: original }]\n      : inversePatches,\n  ] as [T, Patches | undefined, Patches | undefined];\n}\n", "import {\n  Finalities,\n  Options,\n  Patches,\n  PatchesOptions,\n  Result,\n} from './interface';\nimport { createDraft, finalizeDraft } from './draft';\nimport { isDraftable } from './utils';\nimport { dataTypes } from './constant';\n\nexport function draftify<\n  T extends object,\n  O extends PatchesOptions = false,\n  F extends boolean = false\n>(\n  baseState: T,\n  options: Options<O, F>\n): [T, (returnedValue: [T] | []) => Result<T, O, F>] {\n  const finalities: Finalities = {\n    draft: [],\n    revoke: [],\n    handledSet: new WeakSet<any>(),\n  };\n  let patches: Patches | undefined;\n  let inversePatches: Patches | undefined;\n  if (options.enablePatches) {\n    patches = [];\n    inversePatches = [];\n  }\n  const isMutable =\n    options.mark?.(baseState, dataTypes) === dataTypes.mutable ||\n    !isDraftable(baseState, options);\n  const draft = isMutable\n    ? baseState\n    : createDraft({\n        original: baseState,\n        parentDraft: null,\n        finalities,\n        options,\n      });\n  return [\n    draft,\n    (returnedValue: [T] | [] = []) => {\n      const [finalizedState, finalizedPatches, finalizedInversePatches] =\n        finalizeDraft(\n          draft,\n          returnedValue,\n          patches,\n          inversePatches,\n          options.enableAutoFreeze\n        );\n      return (\n        options.enablePatches\n          ? [finalizedState, finalizedPatches, finalizedInversePatches]\n          : finalizedState\n      ) as Result<T, O, F>;\n    },\n  ];\n}\n", "import { DraftType, ProxyDraft } from './interface';\nimport {\n  forEach,\n  get,\n  getProxyDraft,\n  getType,\n  isDraft,\n  isDraftable,\n  isEqual,\n  set,\n  shallowCopy,\n} from './utils';\n\nexport function handleReturnValue<T extends object>(options: {\n  rootDraft: ProxyDraft<any> | undefined;\n  value: T;\n  useRawReturn?: boolean;\n  isContainDraft?: boolean;\n  isRoot?: boolean;\n}) {\n  const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\n  forEach(value, (key, item, source) => {\n    const proxyDraft = getProxyDraft(item);\n    // just handle the draft which is created by the same rootDraft\n    if (\n      proxyDraft &&\n      rootDraft &&\n      proxyDraft.finalities === rootDraft.finalities\n    ) {\n      options.isContainDraft = true;\n      const currentValue = proxyDraft.original;\n      // final update value, but just handle return value\n      if (source instanceof Set) {\n        const arr = Array.from(source);\n        source.clear();\n        arr.forEach((_item) =>\n          source.add(key === _item ? currentValue : _item)\n        );\n      } else {\n        set(source, key, currentValue);\n      }\n    } else if (typeof item === 'object' && item !== null) {\n      options.value = item;\n      options.isRoot = false;\n      handleReturnValue(options);\n    }\n  });\n  if (__DEV__ && isRoot) {\n    if (!options.isContainDraft)\n      console.warn(\n        `The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`\n      );\n\n    if (useRawReturn) {\n      console.warn(\n        `The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`\n      );\n    }\n  }\n}\n\nfunction getCurrent(target: any) {\n  const proxyDraft = getProxyDraft(target);\n  if (!isDraftable(target, proxyDraft?.options)) return target;\n  const type = getType(target);\n  if (proxyDraft && !proxyDraft.operated) return proxyDraft.original;\n  let currentValue: any;\n  function ensureShallowCopy() {\n    currentValue =\n      type === DraftType.Map\n        ? new Map(target)\n        : type === DraftType.Set\n        ? Array.from(proxyDraft!.setMap!.values()!)\n        : shallowCopy(target, proxyDraft?.options);\n  }\n\n  if (proxyDraft) {\n    // It's a proxy draft, let's create a shallow copy eagerly\n    proxyDraft.finalized = true;\n    try {\n      ensureShallowCopy();\n    } finally {\n      proxyDraft.finalized = false;\n    }\n  } else {\n    // It's not a proxy draft, let's use the target directly and let's see\n    // lazily if we need to create a shallow copy\n    currentValue = target;\n  }\n\n  forEach(currentValue, (key, value) => {\n    if (proxyDraft && isEqual(get(proxyDraft.original, key), value)) return;\n    const newValue = getCurrent(value);\n    if (newValue !== value) {\n      if (currentValue === target) ensureShallowCopy();\n      set(currentValue, key, newValue);\n    }\n  });\n  return type === DraftType.Set ? new Set(currentValue) : currentValue;\n}\n\n/**\n * `current(draft)` to get current state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, current } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(current(draft.foo)).toEqual({ bar: 'str2' });\n *   },\n * );\n * ```\n */\nexport function current<T extends object>(target: T): T {\n  if (!isDraft(target)) {\n    throw new Error(`current() is only used for Draft, parameter: ${target}`);\n  }\n  return getCurrent(target);\n}\n", "import {\n  CreateResult,\n  Draft,\n  Mark,\n  Options,\n  ExternalOptions,\n  PatchesOptions,\n  Result,\n} from './interface';\nimport { draftify } from './draftify';\nimport {\n  getProxyDraft,\n  isDraft,\n  isDraftable,\n  isEqual,\n  revokeProxy,\n} from './utils';\nimport { current, handleReturnValue } from './current';\nimport { RAW_RETURN_SYMBOL, dataTypes } from './constant';\n\ntype MakeCreator = <\n  _F extends boolean = false,\n  _O extends PatchesOptions = false\n>(\n  options?: ExternalOptions<_O, _F>\n) => {\n  <\n    T extends any,\n    F extends boolean = _F,\n    O extends PatchesOptions = _O,\n    R extends void | Promise<void> | T | Promise<T> = void\n  >(\n    base: T,\n    mutate: (draft: Draft<T>) => R,\n    options?: ExternalOptions<O, F>\n  ): CreateResult<T, O, F, R>;\n  <\n    T extends any,\n    F extends boolean = _F,\n    O extends PatchesOptions = _O,\n    R extends void | Promise<void> = void\n  >(\n    base: T,\n    mutate: (draft: T) => R,\n    options?: ExternalOptions<O, F>\n  ): CreateResult<T, O, F, R>;\n  <\n    T extends any,\n    P extends any[] = [],\n    F extends boolean = _F,\n    O extends PatchesOptions = _O,\n    R extends void | Promise<void> = void\n  >(\n    mutate: (draft: Draft<T>, ...args: P) => R,\n    options?: ExternalOptions<O, F>\n  ): (base: T, ...args: P) => CreateResult<T, O, F, R>;\n  <T extends any, O extends PatchesOptions = _O, F extends boolean = _F>(\n    base: T,\n    options?: ExternalOptions<O, F>\n  ): [Draft<T>, () => Result<T, O, F>];\n};\n\n/**\n * `makeCreator(options)` to make a creator function.\n *\n * ## Example\n *\n * ```ts\n * import { makeCreator } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const create = makeCreator({ enableAutoFreeze: true });\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * expect(Object.isFrozen(state)).toBeTruthy();\n * ```\n */\nexport const makeCreator: MakeCreator = (arg) => {\n  if (\n    __DEV__ &&\n    arg !== undefined &&\n    Object.prototype.toString.call(arg) !== '[object Object]'\n  ) {\n    throw new Error(\n      `Invalid options: ${String(arg)}, 'options' should be an object.`\n    );\n  }\n  return function create(arg0: any, arg1: any, arg2?: any): any {\n    if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\n      return function (this: any, base: any, ...args: any[]) {\n        return create(\n          base,\n          (draft: any) => arg0.call(this, draft, ...args),\n          arg1\n        );\n      };\n    }\n    const base = arg0;\n    const mutate = arg1 as (...args: any[]) => any;\n    let options = arg2;\n    if (typeof arg1 !== 'function') {\n      options = arg1;\n    }\n    if (\n      __DEV__ &&\n      options !== undefined &&\n      Object.prototype.toString.call(options) !== '[object Object]'\n    ) {\n      throw new Error(\n        `Invalid options: ${options}, 'options' should be an object.`\n      );\n    }\n    options = {\n      ...arg,\n      ...options,\n    };\n    const state = isDraft(base) ? current(base) : base;\n    const mark = Array.isArray(options.mark)\n      ? (((value: unknown, types: typeof dataTypes) => {\n          for (const mark of options.mark as Mark<any, any>[]) {\n            if (__DEV__ && typeof mark !== 'function') {\n              throw new Error(\n                `Invalid mark: ${mark}, 'mark' should be a function.`\n              );\n            }\n            const result = mark(value, types);\n            if (result) {\n              return result;\n            }\n          }\n          return;\n        }) as Mark<any, any>)\n      : options.mark;\n    const enablePatches = options.enablePatches ?? false;\n    const strict = options.strict ?? false;\n    const enableAutoFreeze = options.enableAutoFreeze ?? false;\n    const _options: Options<any, any> = {\n      enableAutoFreeze,\n      mark,\n      strict,\n      enablePatches,\n    };\n    if (\n      !isDraftable(state, _options) &&\n      typeof state === 'object' &&\n      state !== null\n    ) {\n      throw new Error(\n        `Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`\n      );\n    }\n    const [draft, finalize] = draftify(state, _options);\n    if (typeof arg1 !== 'function') {\n      if (!isDraftable(state, _options)) {\n        throw new Error(\n          `Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`\n        );\n      }\n      return [draft, finalize];\n    }\n    let result: any;\n    try {\n      result = mutate(draft);\n    } catch (error) {\n      revokeProxy(getProxyDraft(draft));\n      throw error;\n    }\n    const returnValue = (value: any) => {\n      const proxyDraft = getProxyDraft(draft)!;\n      if (!isDraft(value)) {\n        if (\n          value !== undefined &&\n          !isEqual(value, draft) &&\n          proxyDraft?.operated\n        ) {\n          throw new Error(\n            `Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`\n          );\n        }\n        const rawReturnValue = value?.[RAW_RETURN_SYMBOL] as [any] | undefined;\n        if (rawReturnValue) {\n          const _value = rawReturnValue[0];\n          if (_options.strict && typeof value === 'object' && value !== null) {\n            handleReturnValue({\n              rootDraft: proxyDraft,\n              value,\n              useRawReturn: true,\n            });\n          }\n          return finalize([_value]);\n        }\n        if (value !== undefined) {\n          if (typeof value === 'object' && value !== null) {\n            handleReturnValue({ rootDraft: proxyDraft, value });\n          }\n          return finalize([value]);\n        }\n      }\n      if (value === draft || value === undefined) {\n        return finalize([]);\n      }\n      const returnedProxyDraft = getProxyDraft(value)!;\n      if (_options === returnedProxyDraft.options) {\n        if (returnedProxyDraft.operated) {\n          throw new Error(`Cannot return a modified child draft.`);\n        }\n        return finalize([current(value)]);\n      }\n      return finalize([value]);\n    };\n    if (result instanceof Promise) {\n      return result.then(returnValue, (error) => {\n        revokeProxy(getProxyDraft(draft)!);\n        throw error;\n      });\n    }\n    return returnValue(result);\n  };\n};\n", "import { makeCreator } from './makeCreator';\n\n/**\n * `create(baseState, callback, options)` to create the next state\n *\n * ## Example\n *\n * ```ts\n * import { create } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * ```\n */\nconst create = makeCreator();\n\nexport { create };\n", "import { Draft, Options, Patches, DraftType, Operation } from './interface';\nimport { deepClone, get, getType, isDraft, unescapePath } from './utils';\nimport { create } from './create';\n\n/**\n * `apply(state, patches)` to apply patches to state\n *\n * ## Example\n *\n * ```ts\n * import { create, apply } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const [state, patches] = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n *   { enablePatches: true }\n * );\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\n * expect(state).toEqual(apply(baseState, patches));\n * ```\n */\nexport function apply<T extends object, F extends boolean = false>(\n  state: T,\n  patches: Patches,\n  applyOptions?: Pick<\n    Options<boolean, F>,\n    Exclude<keyof Options<boolean, F>, 'enablePatches'>\n  >\n) {\n  let i: number;\n  for (i = patches.length - 1; i >= 0; i -= 1) {\n    const { value, op, path } = patches[i];\n    if (\n      (!path.length && op === Operation.Replace) ||\n      (path === '' && op === Operation.Add)\n    ) {\n      state = value;\n      break;\n    }\n  }\n  if (i > -1) {\n    patches = patches.slice(i + 1);\n  }\n  const mutate = (draft: Draft<T>) => {\n    patches.forEach((patch) => {\n      const { path: _path, op } = patch;\n      const path = unescapePath(_path);\n      let base: any = draft;\n      for (let index = 0; index < path.length - 1; index += 1) {\n        const parentType = getType(base);\n        let key = path[index];\n        if (typeof key !== 'string' && typeof key !== 'number') {\n          key = String(key);\n        }\n        if (\n          ((parentType === DraftType.Object ||\n            parentType === DraftType.Array) &&\n            (key === '__proto__' || key === 'constructor')) ||\n          (typeof base === 'function' && key === 'prototype')\n        ) {\n          throw new Error(\n            `Patching reserved attributes like __proto__ and constructor is not allowed.`\n          );\n        }\n        // use `index` in Set draft\n        base = get(parentType === DraftType.Set ? Array.from(base) : base, key);\n        if (typeof base !== 'object') {\n          throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\n        }\n      }\n\n      const type = getType(base);\n      // ensure the original patch is not modified.\n      const value = deepClone(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case Operation.Replace:\n          switch (type) {\n            case DraftType.Map:\n              return base.set(key, value);\n            case DraftType.Set:\n              throw new Error(`Cannot apply replace patch to set.`);\n            default:\n              return (base[key] = value);\n          }\n        case Operation.Add:\n          switch (type) {\n            case DraftType.Array:\n              // If the \"-\" character is used to\n              // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\n              // this has the effect of appending the value to the array.\n              return key === '-'\n                ? base.push(value)\n                : base.splice(key as number, 0, value);\n            case DraftType.Map:\n              return base.set(key, value);\n            case DraftType.Set:\n              return base.add(value);\n            default:\n              return (base[key] = value);\n          }\n        case Operation.Remove:\n          switch (type) {\n            case DraftType.Array:\n              return base.splice(key as number, 1);\n            case DraftType.Map:\n              return base.delete(key);\n            case DraftType.Set:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          throw new Error(`Unsupported patch operation: ${op}.`);\n      }\n    });\n  };\n  if (isDraft(state)) {\n    if (applyOptions !== undefined) {\n      throw new Error(`Cannot apply patches with options to a draft.`);\n    }\n    mutate(state as Draft<T>);\n    return state;\n  }\n  return create<T, F>(state, mutate, {\n    ...applyOptions,\n    enablePatches: false,\n  });\n}\n", "import { getProxyDraft } from './utils';\n\n/**\n * `original(draft)` to get original state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, original } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\n *   }\n * );\n * ```\n */\nexport function original<T>(target: T): T {\n  const proxyDraft = getProxyDraft(target);\n  if (!proxyDraft) {\n    throw new Error(\n      `original() is only used for a draft, parameter: ${target}`\n    );\n  }\n  return proxyDraft.original;\n}\n", "import { RAW_RETURN_SYMBOL } from './constant';\n\n/**\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\n *\n * ## Example\n *\n * ```ts\n * import { create, rawReturn } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     return rawReturn(baseState);\n *   },\n * );\n * expect(state).toBe(baseState);\n * ```\n */\nexport function rawReturn<T extends object | undefined>(value: T): T {\n  if (arguments.length === 0) {\n    throw new Error('rawReturn() must be called with a value.');\n  }\n  if (arguments.length > 1) {\n    throw new Error('rawReturn() must be called with one argument.');\n  }\n  if (\n    __DEV__ &&\n    value !== undefined &&\n    (typeof value !== 'object' || value === null)\n  ) {\n    console.warn(\n      'rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().'\n    );\n  }\n  return {\n    [RAW_RETURN_SYMBOL]: [value],\n  } as never;\n}\n", "import { dataTypes } from '../constant';\n\nconst constructorString = Object.prototype.constructor.toString();\n/**\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\n * support case: https://github.com/unadlib/mutative/issues/17\n */\nconst isSimpleObject = (value: unknown) => {\n  if (!value || typeof value !== 'object') return false;\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype === null) {\n    return true;\n  }\n  const constructor =\n    Object.hasOwnProperty.call(prototype, 'constructor') &&\n    prototype.constructor;\n\n  if (constructor === Object) return true;\n\n  return (\n    typeof constructor === 'function' &&\n    Function.toString.call(constructor) === constructorString\n  );\n};\n\nexport const markSimpleObject = (value: unknown) => {\n  if (isSimpleObject(value)) {\n    return dataTypes.immutable;\n  }\n  return;\n};\n", "import { Draft, Immutable } from '../interface';\n\n/**\n * Cast a value to an Draft type value.\n */\nexport function castDraft<T>(value: T): Draft<T> {\n  return value as any;\n}\n\n/**\n * Cast a value to an Immutable type value.\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n  return value as any;\n}\n", "import cjsModule from '../index.js'\n\nexport const configure = cjsModule.configure\n\nexport const stringify = cjsModule\nexport default cjsModule\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Utilities for\n * {@link https://datatracker.ietf.org/doc/html/rfc4648#section-4 | base64}\n * encoding and decoding.\n *\n * This module is browser compatible.\n *\n * ```ts\n * import {\n *   encodeBase64,\n *   decodeBase64,\n * } from \"https://deno.land/std@$STD_VERSION/encoding/base64.ts\";\n *\n * const encoded = encodeBase64(\"foobar\"); // \"Zm9vYmFy\"\n *\n * decodeBase64(encoded); // Uint8Array(6) [ 102, 111, 111, 98, 97, 114 ]\n * ```\n *\n * @module\n */\n\nconst base64abc = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"+\",\n  \"/\",\n];\n\n/**\n * Converts data into a base64-encoded string.\n *\n * @see {@link https://datatracker.ietf.org/doc/html/rfc4648#section-4}\n *\n * @param data The data to encode.\n * @returns The base64-encoded string.\n *\n * @example\n * ```ts\n * import { encodeBase64 } from \"https://deno.land/std@$STD_VERSION/encoding/base64.ts\";\n *\n * encodeBase64(\"foobar\"); // \"Zm9vYmFy\"\n * ```\n */\nexport function encodeBase64(data: ArrayBuffer | Uint8Array | string): string {\n  // CREDIT: https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727\n  const uint8 = validateBinaryLike(data);\n  let result = \"\";\n  let i;\n  const l = uint8.length;\n  for (i = 2; i < l; i += 3) {\n    result += base64abc[uint8[i - 2]! >> 2];\n    result += base64abc[((uint8[i - 2]! & 0x03) << 4) | (uint8[i - 1]! >> 4)];\n    result += base64abc[((uint8[i - 1]! & 0x0f) << 2) | (uint8[i]! >> 6)];\n    result += base64abc[uint8[i]! & 0x3f];\n  }\n  if (i === l + 1) {\n    // 1 octet yet to write\n    result += base64abc[uint8[i - 2]! >> 2];\n    result += base64abc[(uint8[i - 2]! & 0x03) << 4];\n    result += \"==\";\n  }\n  if (i === l) {\n    // 2 octets yet to write\n    result += base64abc[uint8[i - 2]! >> 2];\n    result += base64abc[((uint8[i - 2]! & 0x03) << 4) | (uint8[i - 1]! >> 4)];\n    result += base64abc[(uint8[i - 1]! & 0x0f) << 2];\n    result += \"=\";\n  }\n  return result;\n}\n\n/**\n * Decodes a base64-encoded string.\n *\n * @see {@link https://datatracker.ietf.org/doc/html/rfc4648#section-4}\n *\n * @param b64 The base64-encoded string to decode.\n * @returns The decoded data.\n *\n * @example\n * ```ts\n * import { decodeBase64 } from \"https://deno.land/std@$STD_VERSION/encoding/base64.ts\";\n *\n * decodeBase64(\"Zm9vYmFy\"); // Uint8Array(6) [ 102, 111, 111, 98, 97, 114 ]\n * ```\n */\nexport function decodeBase64(b64: string): Uint8Array {\n  const binString = atob(b64);\n  const size = binString.length;\n  const bytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    bytes[i] = binString.charCodeAt(i);\n  }\n  return bytes;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\nconst encoder = new TextEncoder();\n\nfunction getTypeName(value: unknown): string {\n  const type = typeof value;\n  if (type !== \"object\") {\n    return type;\n  } else if (value === null) {\n    return \"null\";\n  } else {\n    return value?.constructor?.name ?? \"object\";\n  }\n}\n\nexport function validateBinaryLike(source: unknown): Uint8Array {\n  if (typeof source === \"string\") {\n    return encoder.encode(source);\n  } else if (source instanceof Uint8Array) {\n    return source;\n  } else if (source instanceof ArrayBuffer) {\n    return new Uint8Array(source);\n  }\n  throw new TypeError(\n    `The input must be a Uint8Array, a string, or an ArrayBuffer. Received a value of the type ${\n      getTypeName(source)\n    }.`,\n  );\n}\n", "import {\n  DataRef,\n  DataRefType,\n  DataRefTypeDefault,\n  InputsRefs,\n} from \"./types.ts\";\n\nimport { fetchRobust as fetch, sha256Buffer } from \"./util.ts\";\n\nimport { decodeBase64 } from \"./base64.ts\";\n\nimport { DataRefSerializedBlob, MetaframeInputMap } from \"@metapages/metapage\";\n\nexport const ENV_VAR_DATA_ITEM_LENGTH_MAX = 200;\n\nexport const dataRefToDownloadLink = async (ref: DataRef): Promise<string> => {\n  const buffer = await dataRefToBuffer(ref);\n  return URL.createObjectURL(\n    new Blob([buffer], { type: \"application/octet-stream\" }),\n  );\n};\n\nexport const dataRefToBuffer = async (ref: DataRef): Promise<Uint8Array> => {\n  switch (ref.type) {\n    case DataRefType.base64:\n      return decodeBase64(ref.value as string);\n    case DataRefType.utf8:\n      return new TextEncoder().encode(ref.value as string);\n    case DataRefType.json:\n      return new TextEncoder().encode(JSON.stringify(ref.value));\n    case DataRefType.url: {\n      const arrayBufferFromUrl = await urlToUint8Array(ref.value as string);\n      return arrayBufferFromUrl;\n    }\n    case DataRefType.key: {\n      // hard code this for now\n      const arrayBufferFromKey = await fetchBlobFromHash(\n        ref.value,\n        \"https://container.mtfm.io\",\n      );\n      return new Uint8Array(arrayBufferFromKey);\n    }\n    default: // undefined assume DataRefType.Base64\n      throw `Not yet implemented: DataRef.type \"${ref.type}\" unknown`;\n  }\n};\n\n// Takes map of DataRefs and checks if any are too big, if so\n// uploads the data to the cloud, and replaces the data ref\n// with a DataRef pointing to the cloud blob\n// We assume (roughly) immutable uploads based on hash\n// so we keep a tally of already uploaded blobs\nconst AlreadyUploaded: { [hash: string]: boolean } = {};\nexport const copyLargeBlobsToCloud = async (\n  inputs: InputsRefs | undefined,\n  address: string,\n): Promise<InputsRefs | undefined> => {\n  if (!inputs || Object.keys(inputs).length === 0) {\n    return;\n  }\n  const result: InputsRefs = {};\n\n  await Promise.all(\n    Object.keys(inputs).map(async (name) => {\n      const type: DataRefType = inputs[name]?.type || DataRefTypeDefault;\n      let uint8ArrayIfBig: Uint8Array | undefined;\n      switch (type) {\n        case DataRefType.key:\n          // this is already cloud storage. no need to re-upload\n          break;\n        case DataRefType.url:\n          // this is already somewhere else.\n          break;\n        case DataRefType.json:\n          if (inputs?.[name]?.value) {\n            const jsonString = JSON.stringify(inputs[name].value);\n            if (jsonString.length > ENV_VAR_DATA_ITEM_LENGTH_MAX) {\n              uint8ArrayIfBig = utf8ToBuffer(jsonString);\n            }\n          }\n          break;\n        case DataRefType.base64:\n          if (inputs?.[name]?.value.length > ENV_VAR_DATA_ITEM_LENGTH_MAX) {\n            uint8ArrayIfBig = decodeBase64(inputs[name].value);\n          }\n          break;\n        case DataRefType.utf8:\n          if (inputs?.[name]?.value?.length > ENV_VAR_DATA_ITEM_LENGTH_MAX) {\n            uint8ArrayIfBig = utf8ToBuffer(inputs[name].value);\n          }\n          break;\n\n        default:\n      }\n\n      if (uint8ArrayIfBig) {\n        // upload and replace the dataref\n\n        const hash = await sha256Buffer(uint8ArrayIfBig);\n        // but not if we already have, since these files are immutable\n        if (!AlreadyUploaded[hash]) {\n          const urlGetUpload = `${address}/upload/${hash}`;\n          // console.log('urlGetUpload', urlGetUpload);\n          // @ts-ignore: TS2353\n          const resp = await fetch(urlGetUpload, { redirect: \"follow\" });\n          if (!resp.ok) {\n            throw new Error(\n              `Failed to get upload URL from ${urlGetUpload} status=${resp.status}`,\n            );\n          }\n          const json: { url: string; ref: DataRef } = await resp.json();\n          const responseUpload = await fetch(json.url, {\n            // @ts-ignore: TS2353\n            method: \"PUT\",\n            // @ts-ignore: TS2353\n            redirect: \"follow\",\n            body: uint8ArrayIfBig,\n            headers: { \"Content-Type\": \"application/octet-stream\" },\n          });\n          await responseUpload.text();\n          result[name] = json.ref; // the server gave us this ref to use\n          AlreadyUploaded[hash] = true;\n        } else {\n          result[name] = {\n            value: hash,\n            type: DataRefType.key,\n          };\n        }\n      } else {\n        result[name] = inputs[name];\n      }\n    }),\n  );\n  return result;\n};\n\n// Takes map of DataRefs and converts all to desired DataMode\n// e.g. gets urls and downloads to local ArrayBuffers\nexport const convertJobOutputDataRefsToExpectedFormat = async (\n  outputs: InputsRefs | undefined,\n  address: string,\n): Promise<MetaframeInputMap | undefined> => {\n  if (!outputs) {\n    return;\n  }\n  let arrayBuffer: ArrayBuffer;\n  const newOutputs: MetaframeInputMap = {};\n\n  await Promise.all(\n    Object.keys(outputs).map(async (name: string) => {\n      const type: DataRefType = outputs[name].type || DataRefTypeDefault;\n      switch (type) {\n        case DataRefType.base64: {\n          // well that was easy\n          const internalBlobRefFromBase64: DataRefSerializedBlob = {\n            _s: true,\n            _c: \"Blob\",\n            value: outputs[name].value,\n            size: 0,\n            fileType: undefined, // TODO: can we figure this out?\n          };\n          newOutputs[name] = internalBlobRefFromBase64;\n          break;\n        }\n        case DataRefType.key: {\n          arrayBuffer = await fetchBlobFromHash(outputs[name].value, address);\n\n          const internalBlobRefFromHash: DataRefSerializedBlob = {\n            _c: Blob.name,\n            _s: true,\n            value: bufferToBase64(arrayBuffer),\n            size: arrayBuffer.byteLength,\n            fileType: undefined, // TODO: can we figure this out?\n          };\n          newOutputs[name] = internalBlobRefFromHash;\n          break;\n        }\n        case DataRefType.json:\n          newOutputs[name] = outputs[name].value; //Unibabel.utf8ToBase64(JSON.stringify(outputs[name].value));\n          break;\n        case DataRefType.url: {\n          arrayBuffer = await fetchBlobFromUrl(outputs[name].value);\n          const internalBlobRefFromUrl: DataRefSerializedBlob = {\n            _s: true,\n            _c: Blob.name,\n            value: bufferToBase64(arrayBuffer),\n            fileType: undefined, // TODO: can we figure this out?\n            size: arrayBuffer.byteLength,\n          };\n          newOutputs[name] = internalBlobRefFromUrl;\n          break;\n        }\n        case DataRefType.utf8:\n          newOutputs[name] = outputs[name].value; //Unibabel.utf8ToBase64(outputs[name].value);\n          break;\n      }\n    }),\n  );\n\n  return newOutputs;\n};\n\nconst fetchBlobFromUrl = async (url: string): Promise<ArrayBuffer> => {\n  const response = await fetch(url, {\n    // @ts-ignore: TS2353\n    method: \"GET\",\n    // @ts-ignore: TS2353\n    redirect: \"follow\",\n    headers: { \"Content-Type\": \"application/octet-stream\" },\n  });\n  const arrayBuffer = await response.arrayBuffer();\n  return arrayBuffer;\n};\n\nexport const fetchJsonFromUrl = async <T>(url: string): Promise<T> => {\n  const response = await fetch(url, {\n    // @ts-ignore: TS2353\n    method: \"GET\",\n    // @ts-ignore: TS2353\n    redirect: \"follow\",\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n  const json = await response.json();\n  return json;\n};\n\nexport const urlToUint8Array = async (url: string): Promise<Uint8Array> => {\n  // @ts-ignore: TS2353\n  const response = await fetch(url, { redirect: \"follow\" });\n  if (!response.ok) {\n    throw new Error(`Failed to fetch ${url}: ${response.statusText}`);\n  }\n  const arrayBuffer = await response.arrayBuffer();\n  return new Uint8Array(arrayBuffer);\n};\n\nconst fetchBlobFromHash = async (\n  hash: string,\n  address: string,\n): Promise<ArrayBuffer> => {\n  const resp = await fetch(`${address}/download/${hash}`, {\n    // @ts-ignore: TS2353\n    redirect: \"follow\",\n  });\n  const json: { url: string; ref: DataRef } = await resp.json();\n  const arrayBuffer = await fetchBlobFromUrl(json.url);\n  return arrayBuffer;\n};\n\nconst _encoder = new TextEncoder();\nexport const utf8ToBuffer = (str: string): Uint8Array => {\n  return _encoder.encode(str);\n};\n\nconst _decoder = new TextDecoder();\nexport const bufferToUtf8 = (buffer: Uint8Array): string => {\n  return _decoder.decode(buffer);\n};\n\n// \uD83D\uDC4D\nexport function bufferToBinaryString(buffer: ArrayBuffer): string {\n  const base64Str = Array.prototype.map\n    .call(buffer, function (ch: number) {\n      return String.fromCharCode(ch);\n    })\n    .join(\"\");\n  return base64Str;\n}\n\n// \uD83D\uDC4D\nexport const bufferToBase64 = (buffer: ArrayBuffer): string => {\n  const binstr = bufferToBinaryString(buffer);\n  return btoa(binstr);\n};\n"],
  "mappings": "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",
  "names": ["fetchRetry", "fetch", "error", "configure", "value", "tmp", "key", "res", "join", "stringify", "equal", "DataRefType", "DockerJobState", "DockerJobFinishedReason", "WebsocketMessageTypeWorkerToServer", "WebsocketMessageTypeClientToServer", "WebsocketMessageTypeServerBroadcast", "index", "set", "generatePatches", "current", "value", "proxyDraft", "ensureShallowCopy", "create", "base", "draft", "mark", "result", "cjsModule", "cjsModule", "fetchRetry", "equal"]
}
